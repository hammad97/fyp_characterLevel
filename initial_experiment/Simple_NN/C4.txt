Xref: cantaloupe.srv.cs.cmu.edu comp.lang.c:65945 comp.sources.d:9009 comp.unix.wizards:34201 alt.sources:7705 misc.misc:19347 comp.windows.x:64830
Path: cantaloupe.srv.cs.cmu.edu!das-news.harvard.edu!ogicse!network.ucsd.edu!pacbell.com!toad.com!chongo
From: chongo@toad.com (Landon C. Noll)
Newsgroups: comp.lang.c,comp.sources.d,comp.unix.wizards,alt.sources,misc.misc,comp.windows.x
Subject: 10th International Obfuscated C Code Contest Opening (1 of 2)
Keywords: ioccc
Message-ID: <32194@toad.com>
Date: 1 Mar 93 12:08:28 GMT
Article-I.D.: toad.32194
Expires: 7 May 93 00:00:00 GMT
Reply-To: chongo@toad.com.UUCP (Landon C. Noll)
Distribution: world
Organization: Nebula Consultants in San Francisco
Lines: 850

Enclosed are the rules, guidelines and related information for the 10th
International Obfuscated C Code Contest.  (This is part 1 of a 2 part
shar file).

Enjoy!

chongo <Landon Curt Noll> /\oo/\ 
Larry Bassel

=-=

#!/bin/sh
# This is a shell archive (shar 3.32)
# made 03/01/1993 12:01 UTC by chongo@toad.com
# Source directory /tmp
#
# existing files WILL be overwritten
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   8585 -r--r--r-- rules
#  25375 -r--r--r-- guidelines
#  33961 -r--r--r-- mkentry.c
#   6257 -r--r--r-- obfuscate.info
#
# ============= rules ==============
echo "x - extracting rules (Text)"
sed 's/^X//' << 'SHAR_EOF' > rules &&
X10th International Obfuscated C Code Contest Rules
X
XCopyright (c) Landon Curt Noll & Larry Bassel, 1993.  
XAll Rights Reserved.  Permission for personal, education or non-profit use is 
Xgranted provided this this copyright and notice are included in its entirety 
Xand remains unaltered.  All other uses must receive prior permission in writing 
Xfrom both Landon Curt Noll and Larry Bassel.
X
X    Obfuscate:  tr.v.  -cated, -cating, -cates.  1. a.  To render obscure.
X		b.  To darken.  2. To confuse:  his emotions obfuscated his
X		judgment.  [LLat. obfuscare, to darken : ob(intensive) +
X		Lat. fuscare, to darken < fuscus, dark.] -obfuscation n.
X		obfuscatory adj.
X
X
XGOALS OF THE CONTEST:
X
X    * To write the most Obscure/Obfuscated C program under the rules below.
X    * To show the importance of programming style, in an ironic way.
X    * To stress C compilers with unusual code.
X    * To illustrate some of the subtleties of the C language.
X    * To provide a safe forum for poor C code.  :-)
X
X
XRULES:
X
X    To help us with the volume of entries, we ask that you follow these rules:
X
X    1) Your entry must be a complete program.
X
X    2) Your entry must be <= 3217 bytes in length.  The number of characters
X       excluding whitespace (tab, space, newline), and excluding any ; { or }
X       followed by either whitespace or end of file, must be <= 1536.
X
X    3) Your entry must be submitted in the following format:
X
X---entry---
Xrule:	1993
Xfix:	y or n   (n => this is a new entry, y => this replaces an older entry)
Xtitle:	title of entry  		    (see comments below)
Xentry:	Entry number from 0 to 7 inclusive  (your 1st entry should by 0)
Xdate:	Date/time of submission in UTC	    (see comments below)
Xhost:	Machine(s) and OS(s) under which your entry was tested
X	Use tab indented lines if needed
X---remark---
X    Place remarks about this entry in this section.  It would be helpful if
X    you were to indent your remarks with 4 spaces, though it is not a
X    requirement.  Also, if possible, try to avoid going beyond the 79th
X    column.  Blank lines are permitted.
X---author---
Xname:	your name
Xorg:	School/Company/Organization
Xaddr:	postal address
X	use tab indented lines to continue
X	don't forget to include the country
Xemail:  Email address from a well known site or registered domain.
X        If you give several forms, list them on separate tab indented lines.
Xanon:	y or n   (y => remain anonymous, n => ok to publish this info)
X---info---
XIf your program needs an info file, place a uuencoded copy of it in
Xthis section.  In the case of multiple info files, use multiple info
Xsections.  If your entry does not need a info file, skip this section.
X---build---
XPlace a uuencoded copy of the command(s) used to compile/build your program
Xin this section.  It must uudecode into a file named 'build'.  The resulting
Xfile must be 255 bytes or less.
X---program---
XPlace a uuencoded copy of your program in this section.  It must uudecode
Xinto a file named is 'prog.c'.  The resulting file must follow rule #2.
X---end---
X
X      Regarding the above format:
X
X	* The title must match the expression: [a-zA-Z0-9_=][a-zA-Z0-9_=+-]*
X	  and must be 1 to 12 characters in length.
X
X	  It is suggested, but not required, that the title should
X	  incorporate your username; in the case of multiple authors,
X	  consider using parts of the usernames of the authors.
X
X	* The date in the ---entry--- section should be given with respect
X	  to UTC.  The format of the date should be as returned by asctime() 
X	  using the C locale.  (see guidelines for more info)
X
X	* You may correct/revise a previously submitted entry by sending
X	  it to the contest email address.  Be sure to set 'fix' in the 
X	  ---entry--- section to 'n'.  The corrected entry must use the same 
X	  title and entry number as submittion that is being corrected.  Be 
X	  sure that you note the resubmittion in the ---remark--- as well.
X
X	* With the exception of the header, all text outside of the above 
X	  format may be ignored by the judges.  If you need tell the judges
X	  something, put it in the ---remark--- section, or send a separate
X	  Email message to the judges.
X
X	* Information from the ---author--- section will be published unless 
X	  'y' was given to the respective author's 'anon' line.
X
X	* To credit multiple authors, include an ---author--- section for
X	  each author.  Each should start with ---author--- line, and
X	  should be found between the ---entry--- and ---build--- sections.
X
X	* The entry's remarks should include:
X	    - what this program does
X	    - how to run the program (sample args or input)
X	    - special compile or execution instructions, if any
X	    - special filename requirements (see rule 4 and 5)
X	    - information about any ---data--- files
X	    - why you think the program is obfuscated
X	    - note if this entry is a re-submission of a previous entry.
X	    - any other remarks (humorous or otherwise)
X
X	* Do not rot13 your entry's remarks.  You may suggest that certain
X	  portions of your remarks be rot13ed if your entry wins an award.
X
X        * Info files should be used only to supplement your entry.  They 
X	  should not be required to exist.
X
X	  If your entry does not need an info file, skip the ---info---
X	  section.  If your entry needs multiple info files, use multiple 
X	  ---info--- sections, one per info file.  You should describe
X	  each info file in the ---remark--- section.
X
X    4) If your entry is selected as a winner, it will be modified as follows:
X
X	   'build' is incorporated into a makefile, and 'build' is removed
X	   'prog.c' is renamed to your entry's title, followed by an optional
X	       digit, followed by '.c'
X	   your entry is compiled into a file with the name of your entry's
X	       title, possibly followed by a digit
X
X       If your entry requires that a build file exist, state so in your
X       entry's remark section.  The makefile will be arranged to execute a
X       build shell script containing the 'build' information.  The name of
X       this build shell script will be your entry's title, possibly followed
X       by a digit, followed by '.sh'.
X
X       If needed, your entry's remarks should indicate how your entry must
X       be changed in order to deal with the new filenames.
X
X    5) The build file, the source and the resulting executable should be
X       treated as read-only files.  If your entry needs to modify these files,
X       it should make and modify a copy of the appropriate file.  If this
X       occurs, state so in your entry's remarks.
X
X    6) Entries that cannot be compiled by an ANSI C compiler will be rejected.
X       Use of common C (K&R + extensions) is permitted, as long as it does not 
X       cause compile errors for ANSI C compilers.
X
X    7) The program must be of original work.  All programs must be in the
X       public domain.  All copyrighted programs will be rejected.
X
X    8) Entries must be received prior to 07-May-93 0:00 UTC.  (UTC is
X       essentially equivalent to Greenwich Mean Time)  Email your entries to:
X
X		...!{apple,pyramid,sun,uunet}!hoptoad!obfuscate
X		obfuscate@toad.com
X
X       We request that your message use the subject 'ioccc entry'.
X
X       If possible, we request that you hold off on Emailing your entries
X       until 1-Mar-93 0:00 UTC.  Early entries will be accepted, however.
X       We will attempt to email a confirmation to the the first author for
X       all entries received after 1-Mar-93 0:00 UTC.
X
X    9) Each person may submit up to 8 entries per contest year.  Each entry
X       must be sent in a separate Email letter.
X
X   10) Entries requiring human interaction to be built are not allowed.  
X       Compiling an entry produce a file (or files) which may be executed.
X
X   11) Programs that require special privileges (setuid, setgid, super-user,
X       special owner or group) are not allowed.
X    
X
XFOR MORE INFORMATION:
X
X    The Judging will be done by Landon Noll and Larry Bassel.  Please send
X    questions or comments (but not entries) about the contest, to:
X
X	...!{apple,pyramid,sun,uunet}!hoptoad!judges
X	judges@toad.com
X
X    The rules and the guidelines may (and often do) change from year to
X    year.  You should be sure you have the current rules and guidelines
X    prior to submitting entries.  To obtain all 3 of them, send Email
X    to the address above and use the subject 'send rules'.
X
X    One may also obtain them via anonymous ftp from:
X
X	host: ftp.uu.net	(137.39.1.9)
X	user: anonymous
X	pass: yourname@yourhost
X	dir:  /pub/ioccc
X
X
Xchongo <Landon Curt Noll> /\cc/\  	hoptoad!chongo
XLarry Bassel			  	{uunet,ucbvax,cbosgd}|sun!lab
SHAR_EOF
chmod 0444 rules ||
echo "restore of rules failed"
set `wc -c rules`;Wc_c=$1
if test "$Wc_c" != "8585"; then
	echo original size 8585, current size $Wc_c
fi
# ============= guidelines ==============
echo "x - extracting guidelines (Text)"
sed 's/^X//' << 'SHAR_EOF' > guidelines &&
X10th International Obfuscated C Code Contest Guidelines, Hints and Comments
X
XCopyright (c) Landon Curt Noll & Larry Bassel, 1993.  
XAll Rights Reserved.  Permission for personal, education or non-profit use is 
Xgranted provided this this copyright and notice are included in its entirety 
Xand remains unaltered.  All other uses must receive prior permission in writing 
Xfrom both Landon Curt Noll and Larry Bassel.
X
XABOUT THIS FILE:
X
X    This file is intended to help people who wish to submit entries to
X    the International Obfuscated C Code Contest (IOCCC for short).
X
X    This is not the IOCCC rules, though it does contain comments about
X    them.  The guidelines should be viewed as hints and suggestions.
X    Entries that violate the guidelines but remain within the rules are
X    allowed.  Even so, you are safer if you remain within the guidelines.
X
X    You should read the current IOCCC rules, prior to submitting entries.
X    The rules are typically sent out with these guidelines.
X
X
XWHAT IS NEW IN 1993:
X
X    The entry format is better (for us anyway).  The program mkentry.c
X    has been updated.  See ENTRY FORMAT.
X
X    We will reject entries that cannot be compiled using an ANSI C
X    compiler.  Certain old Obfuscation hacks that cause ANSI C compilers 
X    fits are no longer permitted.  Some of the new issues deal with 
X    non-integral array types, variable number of arguments, C preprocessor 
X    directives and the exit() function.  See OUR LIKES AND DISLIKES.
X
X
XHINTS AND SUGGESTIONS:
X
X    You are encouraged to examine the winners of previous contests.  See
X    FOR MORE INFORMATION for details on how to get previous winners.
X
X    Keep in mind that rules change from year to year, so some winning entries
X    may not be valid entries this year.  What was unique and novel one year
X    might be 'old' the next year.
X
X    An entry is usually examined in a number of ways.  We typically apply
X    a number of tests to an entry:
X
X	* look at the original source
X	* convert ANSI tri-graphs to ASCII
X	* C pre-process the source ignoring '#include' lines
X	* C pre-process the source ignoring '#define' and '#include' lines
X	* run it through a C beautifier
X	* examine the algorithm
X	* lint it
X	* compile it
X	* execute it
X
X    You should consider how your entry looks in each of the above tests.
X    You should ask yourself if your entry remains obscure after it has been
X    'cleaned up' by the C pre-processor and a C beautifier.
X
X    Your entry need not do well under all, or in most tests.  In certain
X    cases, a test is not important.  Entries that compete for the
X    'strangest/most creative source layout' need not do as well as
X    others in terms of their algorithm.  On the other hand, given
X    two such entries, we are more inclined to pick the entry that
X    does something interesting when you run it.
X
X    We try to avoid limiting creativity in our rules.  As such, we leave
X    the contest open for creative rule interpretation.  As in real life
X    programming, interpreting a requirements document or a customer request
X    is important.  For this reason, we often award 'worst abuse of the
X    rules' to an entry that illustrates this point in an ironic way.
X
X    If you do plan to abuse the rules, we suggest that you let us know
X    in the remarks section.  Please note that an invitation to abuse
X    is not an invitation to break.  We are strict when it comes to the
X    3217 byte size limit.  Also, abusing the entry format tends to
X    annoy more than amuse.
X
X    We do realize that there are holes in the rules, and invite entries
X    to attempt to exploit them.  We will award 'worst abuse of the rules'
X    and then plug the hole next year.  Even so, we will attempt to use
X    the smallest plug needed, if not smaller.  :-)
X
X    Check out your program and be sure that it works.  We sometimes make
X    the effort to debug an entry that has a slight problem, particularly
X    in or near the final round.  On the other hand, we have seen some
X    of the best entries fall down because they didn't work.
X
X    We tend to look down on a prime number printer, that claims that
X    16 is a prime number.  If you do have a bug, you are better off
X    documenting it.  Noting "this entry sometimes prints the 4th power
X    of a prime by mistake" would save the above entry.  And sometimes,
X    a strange bug/feature can even help the entry!  Of course, a correctly
X    working entry is best.
X
X
XOUR LIKES AND DISLIKES:
X
X    Doing masses of #defines to obscure the source has become 'old'.  We
X    tend to 'see thru' masses of #defines due to our pre-processor tests
X    that we apply.  Simply abusing #defines or -Dfoo=bar won't go as far
X    as a program that is more well rounded in confusion.
X
X    Many ANSI C compilers dislike the following code, and so do we:
X
X	#define d define
X	#d foo		   <-- don't expect this to turn into #define foo
X
X	int i;
X	j;		   <-- don't use such implicit type declaration
X	int k;
X
X    We suggest that you compile your entry with an ANSI C compiler.  If you 
X    must use non-ANSI C, such as K&R C, you must avoid areas that result in 
X    compile/link errors for ANSI C compilers.
X
X    Unfortunately, ANSI C requires array indexes to be of integral type.
X    Thus, the following classical obfuscation hacks are no longer allowed:
X
X	int i;
X	char *c;
X	i[c];		   <--- use c[i] instead
X	(i+3)["string"];   <--- use "string"[i+3] instead
X
X    If your entry uses functions that have a variable number of
X    arguments, be careful. Systems implement va_list as a wide variety
X    of ways.  Because of this, a number of operations using va_list are
X    not portable and must not be used:
X
X	* assigning a non-va_list variable to/from a va_list variable
X	* casting a non-va_list variable into/from a va_list variable
X	* passing a va_list variable to a function expecting a non-va_list arg
X	* passing a non-va_list variable to a function expecting a va_list arg
X	* performing arithmetic on va_list variables
X	* using va_list as a structure or union
X
X    In particular, do not treat va_list variables as if they were a char **'s.
X
X    Avoid using <varargs.h>, use <stdarg.h> instead.
X
X    If you use C preprocessor directives (#define, #if, #ifdef, ...),
X    the leading '#' must be the first character on a line.  While some
X    C preprocessors allow whitespace the leading '#', many do not.
X
X    Because the exit() function returns void on some systems, entries
X    must not assume that it returns an int.
X
X    Small programs are best when they are short, obscure and concise.
X    While such programs are not as complex as other winners, they do
X    serve a useful purpose.  They are often the only program that people
X    attempt to completely understand.  For this reason, we look for
X    programs that are compact, and are instructional.
X
X    One line programs should be short one line programs, say around 80
X    bytes long.  Getting close to 160 bytes is a bit too long in our opinion.
X
X    We tend to dislike programs that:
X
X	* are very hardware specific
X	* are very OS or Un*x version specific
X	     (index/strchr differences are ok, but socket/streams specific
X	      code is likely not to be)
X	* dump core or have compiler warnings
X	     (it is ok only if you warn us in the 'remark' header item)
X	* won't compile under both BSD or SYS V Un*x
X	* abusing the build file to get around the size limit
X	* obfuscate by excessive use of ANSI tri-graphs
X	* are longer than they need to be
X	* are similar to previous winners
X	* are identical to previous losers  :-)
X
X    Unless you are cramped for space, or unless you are entering the
X    'best one liner' category, we suggest that you format your program
X    in a more creative way than simply forming excessively long lines.
X
X    The build file should not be used to try and get around the size
X    limit.  It is one thing to make use of a several -D's to help out,
X    but it is quite another to use 200+ bytes of -D's in order to
X    try and squeeze the source under the size limit.  You should feel
X    free to make use of the build file space, but you are better off
X    if you show some amount of restraint.
X
X    We allowed whitespace, and in certain cases ; { or } do not impact
X    your program size (up to a certain point), because we want to get
X    away from source that is simply a compact blob of characters.
X
X    Given two versions of the same program, one that is a compact blob
X    of code, and the other that is formatted more like a typical C
X    program, we tend to favor the second version.  Of course, a third
X    version of the same program that is formatted in an interesting
X    and/or obfuscated way, would definitely win over the first two!
X
X    We suggest that you avoid trying for the 'smallest self-replicating'
X    program.  We are amazed at the many different sizes that claim
X    to be the smallest.  There is nothing wrong with self-replicating
X    programs.  In fact, a number of winners have been self-replicating.
X    You might want to avoid the claim of 'smallest', lest we (or others)
X    know of a smaller one!
X
X    X client entries should be as portable as possible.  Entries that
X    adapt to a wide collection of environments will be favored.  Don't
X    depend on a particular type of display.  For example, don't depend
X    on color or a given size.  Don't require backing store.
X
X    X client entries should avoid using X related libraries and
X    software that is not in wide spread use.  We ask that such X client
X    entries restrict themselves to only the low level Xlib and the
X    Athena widget set (libX11.a, libXaw.a, libXmu.a and libXt.a).
X    Don't use M*tif, Xv*ew, or OpenL*ok toolkits, since not everyone
X    has them.  Avoid depending on a particular window manager.  Not
X    everyone has X11r5, and some people are stuck back in X11r4 (or
X    earlier), so try to target X11r5 without requiring X11r5.  Better
X    yet, try to make your entry run on all version 11 X Window Systems.
X
X    X client entries should not to depend on particular items on
X    .Xdefaults.  If you must do so, be sure to note the required lines
X    in the ---remark--- section.
X
X    We like programs that:
X
X	* are as concise and small as they need to be
X	* do something at least quasi-interesting
X	* pass lint without complaint (not a requirement, but it is nice)
X	* are portable
X	* are unique or novel in their obfuscation style
X	* MAKE USE OF A NUMBER OF DIFFERENT TYPES OF OBFUSCATION
X	* make us laugh and/or throw up  :-)
X
X    Some types of programs can't excel in some areas.  Of course, your
X    program doesn't have to excel in all areas, but doing well in several
X    areas really does help.
X
X    We freely admit that interesting, creative or humorous comments in
X    the ---remark--- section helps your chance of winning.  If you had to
X    read of many twisted entries, you too would enjoy a good laugh or two.
X    We think the readers of the contest winners do as well.
X
X    Be creative!
X
X
XENTRY FORMAT:
X
X    In order to help us process the many entries, we must request your
X    assistance by formatting your entries in a certain way.  This format,
X    in addition, allows us to quickly separate information about the
X    author from the program itself.  (see JUDGING PROCESS)
X
X    We have provided the program, mkentry, as an example of how to
X    format entries.  You should be aware of the following warning that
X    is found in mkentry.c:
X
X	This program attempts to implement the IOCCC rules.  Every
X	attempt has been made to make sure that this program produces
X	an entry that conforms to the contest rules.  In all cases,
X	where this program differs from the contest rules, the
X	contest rules will be used.  Be sure to check with the
X	contest rules before submitting an entry.
X
X    You are not required to use mkentry.  It is convenient, however,
X    as it attempts to uuencode the needed files, and attempt to check
X    the entry against the size rules.
X
X    If you have any suggestions, comments, fixes or complaints about
X    the mkentry.c program, please send Email to the judges.  (see below)
X
X    The following is a sample entry:
X
X---entry---
Xrule:	1993
Xfix:	n
Xtitle:	chonglab
Xentry:	0
Xdate:	Mon Mar  1 08:45:20 1993
Xhost:	Un*x v6, pdp11/45
X	2.9BSD, pdp11/70
X---remark---
X    This is a non-obfuscated obfuscated C program.
X
X    It is likely not to win a prize.  But what do you expect from
X    a short example!
X---author---
Xname:	Landon Curt Noll
Xorg:	IOCCC Judging Group
Xaddr:	Toad Hall
X	PO Box 170608
X	San Francisco, California
X	94117-0608
X	USA
Xemail:	chongo@toad.com
Xanon:	n
X---author---
Xname:	Larry Bassel
Xorg:	IOCCC Judging Group
Xaddr:	Toad Hall
X	PO Box 170608
X	San Francisco, California
X	94117-0608
X	USA
Xemail:	hoptoad!sun!lab
X	lab@sun.com
Xanon:	n
X---info---
Xbegin 444 info.file
XM0V]P>7)I9VAT("AC*2!,86YD;VX@0W5R="!.;VQL+"`Q.3DS+@I!;&P@4FEG
XM:'1S(%)E<V5R=F5D+B`@4&5R;6ES<VEO;B!F;W(@<&5R<V]N86PL(&5D=6-A
XM=&EO;B!O<B!N;VXM<')O9FET('5S92!I<PIG<F%N=&5D('!R;W9I9&5D('1H
XM:7,@=&AI<R!C;W!Y<FEG:'0@86YD(&YO=&EC92!A<F4@:6YC;'5D960@:6X@
XM:71S(&5N=&ER971Y"F%N9"!R96UA:6YS('5N86QT97)E9"X@($%L;"!O=&AE
XM<B!U<V5S(&UU<W0@<F5C96EV92!P<FEO<B!P97)M:7-S:6]N(&EN('=R:71I
XM;F<*9G)O;2!,86YD;VX@0W5R="!.;VQL+@H*5&AA="!T:&%T(&ES+"!I<RX*
XM5&AA="!T:&%T(&ES(&YO="P*("`@(&ES(&YO="!T:&%T('1H870@;F]T(&ES
XM+@I4:&%T(&ES+"!T:&%T('1H870@:7,@;F]T+"!I<R$*"@D)+2T@8VAO;F=O
XM(#$Y-S0*"DQA<W0@>65A<BP@;VYE('!E<G-O;B!T;VQD('5S('1H870@=&AE
XM>2!A8W1U86QL>2!D96-O9&5D('1H:7,@9FEL92X*22!W;VYD97(@:&]W(&UA
X9;GD@=VEL;"!D;R!I="!T:&ES('EE87(_"@``
X`
Xend
X---build---
Xbegin 444 build
X28V,@<')O9RYC("UO('!R;V<*
X`
Xend
X---program---
Xbegin 444 prog.c
XM;6%I;B@I"GL*(VEF(&1E9FEN960H05]214=)4U1%4D5$7U9/5$527TE.7U-5
XM3DY95D%,15]#04Q)1D]23DE!7U5302D*("`@('!R:6YT9B@B5F]T92!,86YD
XM;VX@3F]L;"!F;W(@4W5N;GEV86QE($-I='D@0V]U;F-I;"!S96%T(",Q+EQN
X:(BD["B-E;F1I9@H@("`@97AI="@P*3L*?0H`
X`
Xend
X---end---
X
X    Typically the build file should assume that the source is prog.c
X    and will compile into prog.  If an entry wins, we will rename
X    its source and binary to avoid filename collision.  By tradition,
X    we use the name of the entry's title, followed by an optional
X    digit in case of name conflicts.
X
X    If the above entry somehow won the 'least likely to win' award,
X    we would use chonglab.c and chonglab.
X
X    If your entry depends on, or requires that your build, source
X    and/or binary files be a particular name, please say so in the
X    ---remark--- section.  If this case applies, it would be be helpful
X    if you did one of the following:
X
X	* Tell us how to change the filename(s) in your entry.
X
X	* Have the build file make copies of the files.  For example:
X
X		cc prog.c -o special_name		need special binary
X
X	    or  rm -f special_src.c			need special source
X		cp prog.c special_src.c
X		cc special_src.c -o special_name
X
X	    or  rm -f special_build			need special build
X		tail +4 build > special_build
X		sh < special_build
X
X	* Assume that we will use the entry title.  Send us a version of 
X	  your build/program files that uses the name convention.  You 
X	  should uuencode these files in ---data--- sections.
X
X    If your entry needs to modify its source, info or binary files,
X    please say so in the ---remark--- section.  You should try to avoid
X    touching your original build, source and binary files.  You should
X    arrange to make copies of the files you intend to modify.  This
X    will allow people to re-generate your entry from scratch.
X
X    Remember that your entry may be built without a build file.  We
X    typically incorporate the build lines into a Makefile.  If the
X    build file must exist, say so in the ---remark--- section.
X
X    If your entry needs special info files, you should uuencode them
X    into ---info--- sections.  In the case of multiple info files,
X    use multiple ---info--- sections.  If no info files are needed,
X    then skip the ---info--- section.
X
X    Info files are intended to be input, or detailed information that
X    does not fit well into the ---remark--- section.  For example, an
X    entry that implements a compiler might want to provide some sample
X    programs for the user to compile.  An entry might want to include a
X    lengthy design document, that might not be appropriate for a
X    'hints' file.
X
X    Info files should be used only to supplement your entry.  For
X    example, info files may provide sample input or detailed
X    information about your entry.  Because they are supplemental,
X    the entry should not require them exist.
X
X    In some cases, your info files might be renamed to avoid name
X    conflicts.  If info files should not be renamed for some reason,
X    say so in the ---remark--- section.
X
X    Info files must uudecode into the current directory.  If they
X    absolutely must be renamed, or moved into a sub-directory, say
X    so in the ---remark--- section.
X
X    When submitting multiple entries, be sure that each entry has
X    a unique entry number from 0 to 7.  Your first entry should
X    have entry number 0.
X
X    With the exception of the header, all text outside of the entry
X    format may be ignored.  That is, don't place text outside of the
X    entry and expect the judges to see it.  (Our decoding tools aren't
X    AI progs!) If you need tell the the something, put it in the 
X    ---remark--- section, or send a Email to the judges at:
X
X	...!{apple,pyramid,sun,uunet}!hoptoad!judges	(not the address for
X	judges@toad.com					 submitting entries)
X    
X    The date should be given with respect to UTC.  (Some systems refer 
X    to this as GMT or GMT0)  The format of the date should be that as 
X    returned by asctime() in the C locale.  An example of such a string is:
X
X	Thr Apr 01 00:47:00 1993
X
X    This format is similar to the output of the date(1) command.  The
X    string does not include the timezone name before the year.  On many 
X    systems, one of the following command will produce a similar string:
X
X	date -u "+%a %h %d %T 19%y"
X	date -u | sed -e 's/... \(19[0-9][0-9]\)$/\1/'
X	sh -c 'TZ=UTC date | sed -e "s/... \(19[0-9][0-9]\)$/\1/"'
X	sh -c 'TZ=GMT date | sed -e "s/... \(19[0-9][0-9]\)$/\1/"'
X	sh -c 'TZ=GMT0 date | sed -e "s/... \(19[0-9][0-9]\)$/\1/"'
X
X    You are allowed to update/fix/revise your entry.  To do so, set
X    the 'fix' line in the ---entry--- section to 'y' instead of 'n'.
X    Be sure that the resubmittion uses the same title and entry number
X    as well, as these are used to determine which entry is to be
X    replaced.
X
X
XJUDGING PROCESS:
X
X    Entries are judged by Larry Bassel and Landon Curt Noll.
X
X    Entries are unpacked into individual directories.  The Email message
X    is unpacked into individual files, each containing:
X
X	---entry--- section
X	all ---author--- sections
X	all ---info--- sections
X	---build--- section
X	---program--- section
X	any other text, including the Email message headers
X
X    Prior to judging, the 'any other text' file is scanned to be sure
X    it does not contain useful information (or in case the entry was
X    malformed and did not unpack correctly).  Information from the
X    ---author--- sections are not read until the judging process is
X    complete, and then only from entries that have won an award.
X
X    The above process helps keep us biased for/against any one particular
X    individual.  We are usually kept in the dark as much as you are
X    until the final awards are given.  We like the surprise of finding
X    out in the end, who won and where they were from.
X
X    We attempt to keep all entries anonymous, unless they win an award.
X    Because the main 'prize' of winning is being announced, we make all
X    attempts to send non-winners into oblivion.  We remove all non-winning
X    files, and shred all related paper.  By tradition, we do not even
X    reveal the number of entries that we received.  (for the curious,
X    we do indicate the volume of paper consumed when presenting the IOCCC
X    winners at talks)
X
X    After the Usenix announcement, we attempt to send Email to the
X    authors of the winning entries.  One reason we do this is to give
X    the authors a chance to comment on the way we have presented their
X    entry.  They are given the chance to correct mistakes, typos.  We
X    often accept their suggestions/comments about our remarks as well.
X    This is done prior to posting the winners to the wide world.
X
X    Judging consists of a number of elimination rounds.  During a round,
X    the collection of entries are divided into two roughly equal piles;
X    the pile that advances on to the next round, and the pile that does
X    not.  We also re-examine the entries that were eliminated in the
X    previous round.  Thus, an entry gets at least two readings.
X
X    A reading consists of a number of actions:
X
X	* reading the ---entry--- section
X	* reading the uudecoded ---build--- section
X	* reading the uudecoded ---program--- section
X	* reading the uudecoded ---info--- section(s), if any
X	* passing the source thru the C pre-processor
X	    shipping over any #include files
X	* performing a number of C beautify/cleanup edits on the source
X	* passing the beautified source thru the C pre-processor
X	    shipping over any #include files
X
X    In later rounds, other actions are performed:
X
X	* linting the source
X	* compiling/building the source
X	* running the program
X	* performing misc tests on the source and binary
X
X    Until we reduce the stack of entries down to about 25 entries, entries
X    are judged on an individual basis.  An entry is set aside because it
X    does not, in our opinion, meet the standard established by the round.
X    When the number of entries thins to about 25 entries, we begin to form
X    award categories.  Entries begin to compete with each other for awards.
X    An entry often will compete in several categories.
X
X    The actual award category list will vary depending on the types of entries
X    we receive.  A typical category list might be:
X
X	* best small one line program
X	* best small program
X	* strangest/most creative source layout
X	* most useful obfuscated program
X	* best game that is obfuscated
X	* most creatively obfuscated program
X	* most deceptive C code
X	* best X client (see OUR LIKES AND DISLIKES)
X	* best abuse of ANSI C
X	* worst abuse of the rules
X	* <anything else so strange that it deserves an award>
X
X    We do not limit ourselves to this list.  For example, a few entries are so
X    good/bad that they are declared winners at the start of the final round.
X    We will invent awards categories for them, if necessary.
X
X    In the final round process, we perform the difficult tasks of
X    reducing the remaining entries (typically about 25) down to 8 or 10
X    winners.  Often we are confident that the entries that make it into
X    the final round are definitely better than the ones that do not
X    make it.  The selection of the winners out of the final round, is
X    less clear cut.
X
X    Sometimes a final round entry good enough to win, but is beat out
X    by a similar, but slightly better entry.  For this reason, it is
X    sometimes worthwhile to re-enter an improved version of an entry 
X    that failed to win in a previous year.  This assumes, of course, 
X    that the entry is worth improving in the first place!
X
X    More often that not, we select a small entry (usually one line), a
X    strange/creative layout entry, and an entry that abuses the contest
X    rules in some way.
X
X    In the end, we traditionally pick one entry as 'best'.  Sometimes such
X    an entry simply far exceeds any of the other entry.  More often, the
X    'best' is picked because it does well in a number of categories.
X
X
XANNOUNCEMENT OF WINNERS:
X
X    The first announcement, occurs at a Summer Usenix conference.  By tradition,
X    this is done during the latter part of the UUNET/IOCCC BOF, just prior to
X    the Berkeley BSD, and BSDI BOF.
X
X    Winning entries will be posted in late June to the following groups:
X
X	    comp.lang.c		  comp.unix.wizards	alt.sources
X
X    In addition, pointers to these postings are posted to the following
X
X	    comp.sources.d	  alt.sources.d		misc.misc
X	    comp.sources.misc	  comp.windows.x
X
X    Winning entries will be deposited into the uunet archives.  See
X    below for details.
X
X    Often, winning entries are published in selected magazines.  Winners 
X    have appeared in books ("The New Hackers Dictionary") and on T-Shirts.
X
X    Last, but not least, winners receive international fame and flames!  :-)
X
X
XFOR MORE INFORMATION:
X
X    You may contact the judges by sending Email to the following address:
X
X	...!{apple,pyramid,sun,uunet}!hoptoad!judges	(not the address for
X	judges@toad.com					 submitting entries)
X
X    Questions and comments about the contest are welcome.
X
X    One may obtain a copy of the current rules, guidelines or mkentry
X    program.  To obtain all 3 of them, send Email to the address above 
X    and use the subject 'send rules'.
X
X    One may also obtain the above items, we well as winners of previous
X    contests, via anonymous ftp from:
X
X	host: ftp.uu.net	(137.39.1.9)
X	user: anonymous
X	pass: yourname@yourhost
X	dir:  pub/ioccc
X
X    Often, contest rules, guidelines and winners are available from
X    archive sites.  Check comp.sources.unix archives, for example.
X    You may also request previous winners by Email, using the judges
X    Email address, though we ask that you do this as a last resort.
X
X
Xchongo <Landon Curt Noll> /\cc/\  	hoptoad!chongo
XLarry Bassel			  	{uunet,ucbvax,cbosgd}|sun!lab
SHAR_EOF
chmod 0444 guidelines ||
echo "restore of guidelines failed"
set `wc -c guidelines`;Wc_c=$1
if test "$Wc_c" != "25375"; then
	echo original size 25375, current size $Wc_c
fi
echo "End of part 1, continue with part 2"
exit 0
-- 
Sunnyvale residents: Vote Landon Noll for Sunnyvale City Council seat 1.
Xref: cantaloupe.srv.cs.cmu.edu comp.lang.c:65946 comp.sources.d:9010 comp.unix.wizards:34202 alt.sources:7706 misc.misc:19348 comp.windows.x:64831
Path: cantaloupe.srv.cs.cmu.edu!das-news.harvard.edu!ogicse!network.ucsd.edu!pacbell.com!toad.com!chongo
From: chongo@toad.com (Landon C. Noll)
Newsgroups: comp.lang.c,comp.sources.d,comp.unix.wizards,alt.sources,misc.misc,comp.windows.x
Subject: 10th International Obfuscated C Code Contest Opening (part 2 of 2)
Message-ID: <32195@toad.com>
Date: 1 Mar 93 12:10:37 GMT
Article-I.D.: toad.32195
Expires: 7 May 93 00:00:00 GMT
Reply-To: chongo@toad.com.UUCP (Landon C. Noll)
Distribution: world
Organization: Nebula Consultants in San Francisco
Lines: 1382

Enclosed are the rules, guidelines and related information for the 10th
International Obfuscated C Code Contest.  (This is part 2 of a 2 part
shar file).

Enjoy!

chongo <Landon Curt Noll> /\oo/\
Larry Bassel

=-=

#!/bin/sh
# This is part 02 of a multipart archive
# ============= mkentry.c ==============
echo "x - extracting mkentry.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > mkentry.c &&
X/* @(#)mkentry.c	1.24 3/1/93 02:28:49 */
X/*
X * Copyright (c) Landon Curt Noll & Larry Bassel, 1993.  
X * All Rights Reserved.  Permission for personal, education or non-profit use 
X * is granted provided this this copyright and notice are included in its 
X * entirety and remains unaltered.  All other uses must receive prior 
X * permission in writing from both Landon Curt Noll and Larry Bassel.
X */
X/*
X * mkentry - make an International Obfuscated C Code Contest entry
X *
X * usage:
X *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
X *
X *	-r remarks		file with remarks about the entry
X *	-b build		file containing how prog.c should be built
X *	-p prog.c		the obfuscated program source file
X *	-o ioccc.entry		ioccc entry output file
X *
X * compile by:
X *	cc mkentry.c -o mkentry
X */
X/*
X * Placed in the public domain by Landon Curt Noll, 1992.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X/*
X * WARNING:
X *
X * This program attempts to implement the IOCCC rules.  Every attempt
X * has been made to make sure that this program produces an entry that
X * conforms to the contest rules.  In all cases, where this program
X * differs from the contest rules, the contest rules will be used.  Be
X * sure to check with the contest rules before submitting an entry.
X *
X * Send questions or comments (but not entries) about the contest, to:
X *
X *	...!{sun,pacbell,uunet,pyramid}!hoptoad!judges
X *	judges@toad.com
X * The rules and the guidelines may (and often do) change from year to
X * year.  You should be sure you have the current rules and guidelines
X * prior to submitting entries.  To obtain all 3 of them, send Email
X * to the address above and use the subject 'send rules'.
X *
X * Because contest rules change from year to year, one should only use this
X * program for the year that it was intended.  Be sure that the RULE_YEAR
X * define below matches this current year.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include <time.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X/* logic */
X#ifndef TRUE
X# define TRUE 1
X#endif /* TRUE */
X#ifndef FALSE
X# define FALSE 0
X#endif /* FALSE */
X#define EOF_OK TRUE
X#define EOF_NOT_OK FALSE
X
X/* global limits */
X#define RULE_YEAR 1993		/* NOTE: should match the current year */
X#define START_DATE "1Mar92 0:00 UTC"	/* first confirmation received */
X#define MAX_COL 79		/* max column a line should hit */
X#define MAX_BUILD_SIZE 256	/* max how to build size */
X#define MAX_PROGRAM_SIZE 3217	/* max program source size */
X#define MAX_PROGRAM_SIZE2 1536	/* max program source size not counting
X				   whitespace and {}; not followed by
X				   whitespace or EOF */
X#define MAX_TITLE_LEN 12	/* max chars in the title */
X#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
X#define MAX_ENTRY 8		/* max number of entries per person per year */
X#define MAX_FILE_LEN 1024	/* max filename length for a info file */
X
X/* where to send entries */
X#define ENTRY_ADDR1 "...!{apple,pyramid,sun,uunet}!hoptoad!obfuscate"
X#define ENTRY_ADDR2 "obfuscate@toad.com"
X
X/* uuencode process - assumes ASCII */
X#define UUENCODE(c) (encode_str[(int)(c)&0xff])
X#define UUENCODE_LEN 45		/* max uuencode chunk size */
X#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
X#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
X#define UUBUILD_NAME "build"	/* name for the build file's uuencode file */
X#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
X#define UUPROG_NAME "prog.c"	/* name for the program's uuencode file */
X
X/* encode_str[(char)val] is the uuencoded character of val */
Xchar encode_str[256+1] = "`!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";
X
X/* global declarations */
Xchar *program;			/* our name */
Xlong start_time;		/* the startup time */
X
X/* forward declarations */
Xvoid parse_args();
Xvoid usage();
XFILE *open_remark();
XFILE *open_build();
XFILE *open_program();
XFILE *open_output();
Xvoid output_entry();
Xvoid output_remark();
Xvoid output_author();
Xvoid output_info();
Xvoid output_build();
Xvoid output_program();
Xvoid output_end();
Xint get_line();
Xvoid output_till_dot();
Xint col_len();
Xvoid check_io();
Xvoid uuencode();
X
Xmain(argc, argv)
X    int argc;		/* arg count */
X    char **argv;	/* the args */
X{
X    FILE *remark=NULL;	/* open remarks stream */
X    FILE *build=NULL;	/* open build file stream */
X    FILE *prog=NULL;	/* open program stream */
X    FILE *output=NULL;	/* open output stream */
X    char *rname=NULL;	/* file with remarks about the entry */
X    char *bname=NULL;	/* file containing how prog.c should be built */
X    char *pname=NULL;	/* the obfuscated program source file */
X    char *oname=NULL;	/* ioccc entry output file */
X    struct tm *tm;	/* startup time structure */
X
X    /*
X     * check on the year
X     */
X    start_time = time((long *)0);
X    tm = gmtime(&start_time);
X    if (tm->tm_year != RULE_YEAR-1900) {
X	fprintf(stderr,
X	"%s: WARNING: this program applies to %d, which may differ from %d\n\n",
X	    argv[0], RULE_YEAR, 1900+tm->tm_year);
X    }
X
X    /*
X     * parse the command line args
X     */
X    parse_args(argc, argv, &rname, &bname, &pname, &oname);
X
X    /*
X     * open/check the input and output files
X     *
X     * We open and truncate the output file first, in case it is the same
X     * as one of the input files.
X     */
X    output = open_output(oname);
X    remark = open_remark(rname);
X    build = open_build(bname);
X    prog = open_program(pname);
X    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
X	exit(1);
X    }
X
X    /*
X     * output each section
X     */
X    output_entry(output, oname);
X    output_remark(output, oname, remark, rname);
X    output_author(output, oname);
X    output_info(output, oname);
X    output_build(output, oname, build, bname);
X    output_program(output, oname, prog, pname);
X    output_end(output, oname);
X
X    /* 
X     * flush the output 
X     */
X    if (fflush(output) == EOF) {
X	fprintf(stderr, "%s: flush error in %s: ", program, oname);
X	perror("");
X	exit(2);
X    }
X
X    /*
X     * final words
X     */
X    printf("\nYour entry can be found in %s.  You should check this file\n", 
X	oname);
X    printf("correct any problems and verify that the uudecode utility will\n");
X    printf("correctly decode your build file and program.\n\n");
X    printf("This program has been provided as a guide for submitters.  In\n");
X    printf("cases where it conflicts with the rules, the rules shall apply.\n");
X    printf("It is your responsibility to ensure that your entry conforms to\n");
X    printf("the current rules.\n\n");
X    printf("Email your entries to:\n");
X    printf("\t%s\n", ENTRY_ADDR1);
X    printf("\t%s\n\n", ENTRY_ADDR2);
X    printf("Please use the following subject when you Email your entry:\n");
X    printf("\tioccc entry\n\n");
X    /* all done */
X    exit(0);
X}
X
X/*
X * parse_args - parse the command line args
X *
X * Given the command line args, this function parses them and sets the
X * required name flags.  This function will return only if the command
X * line syntax is correct.
X */
Xvoid
Xparse_args(argc, argv, rname, bname, pname, oname)
X    int argc;		/* arg count */
X    char **argv;	/* the args */
X    char **rname;	/* file with remarks about the entry */
X    char **bname;	/* file containing how prog.c should be built */
X    char **pname;	/* the obfuscated program source file */
X    char **oname;	/* ioccc entry output file */
X{
X    char *optarg;	/* -flag option operand */
X    int flagname;	/* the name of the -flag */
X    int i;
X
X    /*
X     * Not everyone has getopt, so we must parse args by hand.
X     */
X    program = argv[0];
X    for (i=1; i < argc; ++i) {
X
X	/* determine the flagname */
X	if (argv[i][0] != '-') {
X	    usage(1);
X	    /*NOTREACHED*/
X	}
X	flagname = (int)argv[i][1];
X
X	/* determine the flag's operand */
X	if (flagname != '\0' && argv[i][2] != '\0') {
X	    optarg = &argv[i][2];
X	} else {
X	    if (i+1 >= argc) {
X		usage(2);
X		/*NOTREACHED*/
X	    } else {
X		optarg = argv[++i];
X	    }
X	}
X
X	/* save the flag's operand in the correct global variable */
X	switch (flagname) {
X	case 'r':
X	    *rname = optarg;
X	    break;
X	case 'b':
X	    *bname = optarg;
X	    break;
X	case 'p':
X	    *pname = optarg;
X	    break;
X	case 'o':
X	    *oname = optarg;
X	    break;
X	default:
X	    usage(3);
X	    /*NOTREACHED*/
X	}
X    }
X
X    /*
X     * verify that we have all of the required flags
X     */
X    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
X	usage(4);
X	/*NOTREACHED*/
X    }
X    return;
X}
X
X/*
X * usage - print a usage message and exit
X *
X * This function does not return.
X */
Xvoid
Xusage(exitval)
X    int exitval;		/* exit with this value */
X{
X    fprintf(stderr,
X	"usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n", program);
X    fprintf(stderr, "\t-r remarks\tfile with remarks about the entry\n");
X    fprintf(stderr, "\t-b build\tfile containing how prog.c should be built\n");
X    fprintf(stderr, "\t-p prog.c\tthe obfuscated program source file\n");
X    fprintf(stderr, "\t-o ioccc.entry\tioccc entry output file\n");
X    exit(exitval);
X}
X
X/*
X * open_remark - open/check the remark file
X *
X * The remark file should be indented by 4 spaces, and should not extend 
X * beyond column MAX_COL.  These are not requirements, so we only warn.
X *
X * This function returns NULL on I/O or format error.
X */
XFILE *
Xopen_remark(filename)
X    char *filename;
X{
X    FILE *stream;		/* the opened file stream */
X    char buf[BUFSIZ+1];		/* input buffer */
X    int toolong=0;		/* number of lines that are too long */
X    int non_indent=0;		/* number of lines not indented by 4 spaces */
X
X    /*
X     * open the remark input file
X     */
X    stream = fopen(filename, "r");
X    if (stream == NULL) {
X	fprintf(stderr, "%s: cannot open remark file: %s: ",
X	    program, filename);
X	perror("");
X	return(NULL);
X    }
X
X    /*
X     * look at each line
X     */
X    while (fgets(buf, BUFSIZ, stream) != NULL) {
X
X	/* count lines that do not start with 4 spaces */
X	if (buf[0] != '\n' && strncmp(buf, "    ", 4) != 0) {
X	    ++non_indent;
X	}
X
X	/* count long lines */
X	if (col_len(buf) > MAX_COL) {
X	    /* found a line that is too long */
X	    ++toolong;
X	}
X    }
X
X    /* watch for I/O errors */
X    check_io(stream, filename, EOF_OK);
X
X    /* note long lines if needed */
X    if (toolong > 0) {
X	fprintf(stderr,
X	    "%s: WARNING: %d line(s) from %s extend beyond the 80th column\n",
X	    program, toolong, filename);
X	fprintf(stderr,
X	    "%s:          This is ok, but it would be nice to avoid\n\n",
X	    program);
X    }
X
X    /* note non-indented lines, if needed */
X    if (non_indent > 0) {
X	fprintf(stderr,
X	    "%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n",
X	    program, non_indent, filename);
X	fprintf(stderr,
X	    "%s:          This is ok, but it would be nice to avoid\n\n",
X	    program);
X    }
X
X    /* return the open file */
X    rewind(stream);
X    return(stream);
X}
X
X/*
X * open_build - open/check the build file
X *
X * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
X *
X * This function returns NULL on I/O or size error.
X */
XFILE *
Xopen_build(filename)
X    char *filename;
X{
X    FILE *stream;		/* the opened file stream */
X    struct stat statbuf;	/* the status of the open file */
X
X    /*
X     * open the how to build input file
X     */
X    stream = fopen(filename, "r");
X    if (stream == NULL) {
X	fprintf(stderr, "%s: cannot open how to build file: %s: ",
X	    program, filename);
X	perror("");
X	return(NULL);
X    }
X
X    /*
X     * determine the size of the file
X     */
X    if (fstat(fileno(stream), &statbuf) < 0) {
X	fprintf(stderr, "%s: cannot stat how to build file: %s: ",
X	    program, filename);
X	perror("");
X	return(NULL);
X    }
X    if (statbuf.st_size > MAX_BUILD_SIZE) {
X	fprintf(stderr,
X	    "%s: FATAL: the how to build file: %s, is %d bytes long\n",
X	    program, filename, statbuf.st_size);
X	fprintf(stderr,
X	    "%s:        it may not be longer than %d bytes\n",
X	    program, MAX_BUILD_SIZE);
X	return(NULL);
X    }
X
X    /* return the open file */
X    return(stream);
X}
X
X/*
X * open_program - open/check the program source file
X *
X * The program source file must be <= 3217 bytes.  The number of
X * non-whitespace and }{; chars not followed by whitespace must
X * be <= 1536 bytes.
X *
X * This function returns NULL on I/O or size error.
X */
XFILE *
Xopen_program(filename)
X    char *filename;
X{
X    FILE *stream;		/* the opened file stream */
X    struct stat statbuf;	/* the status of the open file */
X    int count;			/* special count size */
X    int c;			/* the character read */
X
X    /*
X     * open the program source input file
X     */
X    stream = fopen(filename, "r");
X    if (stream == NULL) {
X	fprintf(stderr, "%s: cannot open program source file: %s: ",
X	    program, filename);
X	perror("");
X	exit(7);
X    }
X
X    /*
X     * determine the size of the file
X     */
X    if (fstat(fileno(stream), &statbuf) < 0) {
X	fprintf(stderr, "%s: cannot stat program source file: %s: ",
X	    program, filename);
X	perror("");
X	return(NULL);
X    }
X    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
X	fprintf(stderr,
X	    "%s: FATAL: the program source file: %s, is %d bytes long\n",
X	    program, filename, statbuf.st_size);
X	fprintf(stderr,
X	    "%s:        it may not be longer than %d bytes\n",
X	    program, MAX_PROGRAM_SIZE);
X	return(NULL);
X    }
X
X    /*
X     * count the non-whitespace, non {}; followed by whitespace chars
X     */
X    count = 0;
X    c = 0;
X    while ((c=fgetc(stream)) != EOF) {
X	/* look at non-whitespace */
X	if (!isascii(c) || !isspace(c)) {
X	    switch (c) {
X	    case '{':		/* count if not followed by EOF or whitespace */
X	    case '}':
X	    case ';':
X		/* peek at next char */
X		c = fgetc(stream);
X		if (c != EOF && isascii(c) && !isspace(c)) {
X		    /* not followed by whitespace or EOF, count it */
X		    ungetc(c, stream);
X		    ++count;
X		}
X		break;
X	    default:
X		++count;
X		break;
X	    }
X	}
X    }
X
X    /* watch for I/O errors */
X    check_io(stream, filename, EOF_OK);
X
X    /* look at the special size */
X    if (count > MAX_PROGRAM_SIZE2) {
X	fprintf(stderr,
X	    "%s: FATAL: the number of bytes that are non-whitespace, and\n",
X	    program);
X	fprintf(stderr,
X	    "%s:        that are not '{', '}', ';' followed by whitespace\n",
X	    program);
X	fprintf(stderr,
X	    "%s:        or EOF must be <= %d bytes\n",
X	    program, MAX_PROGRAM_SIZE2);
X	fprintf(stderr,
X	    "%s:        in %s, %d bytes were found\n",
X	    program, filename, count);
X	return(NULL);
X    }
X
X    /* return the open file */
X    rewind(stream);
X    return(stream);
X}
X
X/*
X * open_output - open/check the entry output file
X *
X * This function returns NULL on open error.
X */
XFILE *
Xopen_output(filename)
X    char *filename;
X{
X    FILE *stream;		/* the opened file stream */
X
X    /*
X     * open the ioccc entry output file
X     */
X    stream = fopen(filename, "w");
X    if (stream == NULL) {
X	fprintf(stderr, "%s: cannot open ioccc entry file for output: %s: ",
X	    program, filename);
X	perror("");
X	exit(8);
X    }
X
X    /* return the open file */
X    return(stream);
X}
X
X/*
X * output_entry - output the ---entry--- section
X *
X * Read the needed information form stdin, and write the entry section.
X */
Xvoid
Xoutput_entry(output, oname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X{
X    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
X    char buf[MAX_COL+1+1];		/* I/O buffer */
X    int entry=0;			/* entry number */
X    int ret;				/* fields processed by fscanf */
X    int ok_line=0;			/* 0 => the line is not ok */
X    char skip;				/* input to skip */
X    FILE *date_pipe;			/* pipe to a date command */
X    time_t epoch_sec;			/* seconds since the epoch */
X    char *p;
X
X    /*
X     * write the start of the section
X     */
X    fprintf(output, "---entry---\n");
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * write the rule year
X     */
X    fprintf(output, "rule:\t%d\n", RULE_YEAR);
X    check_io(output, oname, EOF_NOT_OK);
X
X    /* determine if this is a fix */
X    printf("Is this a fix, update or resubmittion to a ");
X    printf("previous entry (enter y or n)? ");
X    while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
X	printf("\nplease answer y or n: ");
X    }
X    if (buf[0] == 'y') {
X	fprintf(output, "fix:\ty\n");
X	check_io(output, oname, EOF_NOT_OK);
X	printf("\nBe sure that the title and entry number that you give\n");
X	printf("are the same of as the entry you are replacing\n");
X    } else {
X	fprintf(output, "fix:\tn\n");
X	check_io(output, oname, EOF_NOT_OK);
X    }
X
X    /*
X     * write the title
X     */
X    printf("\nYour title must match expression be a [a-zA-Z0-9_=] character\n");
X    printf("followed by 0 to %d more [a-zA-Z0-9_=+-] characters.\n\n",
X	MAX_TITLE_LEN-1);
X    printf("It is suggested, but not required, that the title should\n");
X    printf("incorporate your username; in the\n");
X    printf("case of multiple authors, consider using parts of the usernames\n");
X    printf("of the authors.\n\n");
X    printf("enter your title: ");
X    do {
X	/* prompt and read a line */
X	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
X	    printf("\ntitle is too long, please re-enter: ");
X	    continue;
X	}
X
X	/* verify the pattern, not everyone has regexp, so do it by hand */
X	if (!isascii((int)title[0]) ||
X	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '=')) {
X	    printf("\ninvalid first character in the title\n\n");
X	    printf("enter your title: ");
X	    ok_line = 0;
X	} else {
X	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
X		if (!isascii((int)*p) ||
X		    !(isalnum((int)*p) || 
X		      *p == '_' || *p == '=' || *p == '+' || *p == '-')) {
X		    printf("\ninvalid character in the title\n\n");
X		    printf("enter your title: ");
X		    ok_line = 0;
X		}
X	    }
X	}
X    } while (ok_line <= 0);
X    fprintf(output, "title:\t%s", title);
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * write the entry number
X     */
X    printf("\nEach person may submit up to %d entries per year.\n\n",
X	MAX_ENTRY);
X    printf("enter an entry number from 0 to %d inclusive: ", MAX_ENTRY-1);
X    do {
X	/* get a valid input line */
X	fflush(stdout);
X	ret = fscanf(stdin, "%d[\n]", &entry);
X	check_io(stdin, "stdin", EOF_NOT_OK);
X	/* skip over input until newline is found */
X	do {
X	    skip = fgetc(stdin);
X	    check_io(stdin, "stdin", EOF_NOT_OK);
X	    if (skip != '\n') {
X		/* bad text in input, invalidate entry number */
X		entry = -1;
X	    }
X	} while (skip != '\n');
X
X	/* check if we have a number, and if it is in range */
X	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
X	    printf(
X	      "\nThe entry number must be between 0 and %d inclusive\n\n",
X		MAX_ENTRY-1);
X	    printf("enter the entry number: ");
X	}
X    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
X    fprintf(output, "entry:\t%d\n", entry);
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * write the submission date
X     */
X    /* returns a newline */
X    epoch_sec = time(NULL);
X    fprintf(output, "date:\t%s", asctime(gmtime(&epoch_sec)));
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * write the OS/machine host information
X     */
X    printf(
X      "\nEnter the machine(s) and OS(s) under which your entry was tested.\n");
X    output_till_dot(output, oname, "host:");
X}
X
X/*
X * output_remark - output the ---remark--- section
X *
X * Read the needed information form stdin, and write the entry section.
X */
Xvoid
Xoutput_remark(output, oname, remark, rname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X    FILE *remark;		/* stream to the file containing remark text */
X    char *rname;		/* name of the remark file */
X{
X    char buf[BUFSIZ+1];		/* input/output buffer */
X
X    /*
X     * write the start of the section
X     */
X    fprintf(output, "---remark---\n");
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * copy the remark file to the section
X     */
X    while (fgets(buf, BUFSIZ, remark) != NULL) {
X	fputs(buf, output);
X	check_io(output, oname, EOF_NOT_OK);
X    }
X    check_io(remark, rname, EOF_OK);
X
X    /* be sure that the remark section ends with a newline */
X    if (buf[strlen(buf)-1] != '\n') {
X	fputc('\n', output);
X	check_io(output, oname, EOF_NOT_OK);
X    }
X}
X
X/*
X * output_author - output the ---author--- section
X *
X * Read the needed information from stdin, and write the author section.
X * If multiple authors exist, multiple author sections will be written.
X */
Xvoid
Xoutput_author(output, oname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X{
X    char buf[MAX_COL+1+1];	/* I/O buffer */
X    int more_auths;		/* TRUE => more authors to note */
X    int auth_cnt=0;		/* number of authors processed */
X
X    /*
X     * prompt the user for the author section
X     */
X    printf("\nEnter information about each author.  If your entry is after\n");
X    printf("%s and before the contest deadline, the judges\n", START_DATE);
X    printf("will attempt to Email back a confirmation to the first author\n");
X
X    /*
X     * place author information for each author in an individual section
X     */
X    do {
X
X	/* write the start of the section */
X	fprintf(output, "---author---\n");
X	check_io(output, oname, EOF_NOT_OK);
X
X	/* write the author */
X	printf("\nAuthor #%d name: ", ++auth_cnt);
X	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
X	    printf("\nname too long, please re-enter: ");
X	}
X	fprintf(output, "name:\t%s", buf);
X	check_io(output, oname, EOF_NOT_OK);
X
X	/* write the organization */
X	printf("\nEnter the School/Company/Organization of author #%d\n",
X	    auth_cnt);
X	printf("\nAuthor #%d org: ", auth_cnt);
X	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
X	    printf("\nline too long, please re-enter: ");
X	}
X	fprintf(output, "org:\t%s", buf);
X	check_io(output, oname, EOF_NOT_OK);
X
X	/* write the address */
X	printf(
X	    "\nEnter the postal address for author #%d.  Be sure to include\n",
X	    auth_cnt);
X	printf("your country and do not include your name.\n");
X	output_till_dot(output, oname, "addr:");
X
X	/* write the Email address */
X	printf(
X	    "\nEnter the Email address for author #%d.  Use an address from\n",
X	    auth_cnt);
X	printf(
X	    "a registered domain or well known site.  If you give several\n");
X	printf("forms, list them one per line.\n");
X	output_till_dot(output, oname, "email:");
X
X	/* write the anonymous status */
X	printf("\nShould author #%d remain anonymous (enter y or n)? ",
X	    auth_cnt);
X	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
X	    printf("\nplease answer y or n: ");
X	}
X	fprintf(output, "anon:\t%s", buf);
X	check_io(output, oname, EOF_NOT_OK);
X
X	/* determine if there is another author */
X	printf("\nIs there another author (enter y or n)? ");
X	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
X	    printf("\nplease answer y or n: ");
X	}
X	if (buf[0] == 'y') {
X	    more_auths = TRUE;
X	} else {
X	    more_auths = FALSE;
X	}
X    } while (more_auths == TRUE);
X    return;
X}
X
X/*
X * output_info - output the ---info--- section(s)
X *
X * Read the needed information from stdin, and write the info section.
X * If multiple info files exist, multiple info sections will be written.
X */
Xvoid
Xoutput_info(output, oname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X{
X    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
X    char yorn[1+1];		/* y or n answer */
X    char *uuname;		/* name to uuencode as */
X    FILE *infile;		/* info file stream */
X
X    /*
X     * prompt the user for info information
X     */
X    printf("\nInfo files should be used only to supplement your entry.\n");
X    printf("For example, info files may provide sample input or detailed\n");
X    printf("information about your entry.  Because they are supplemental,\n");
X    printf("the entry should not require them to exist.\n\n");
X
X    /*
X     * while there is another info file to save, uuencode it
X     */
X    printf("Do you have a info file to include (enter y or n)? ");
X    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
X	printf("\nplease answer y or n: ");
X    }
X    while (yorn[0] == 'y') {
X
X	/* read the filename */
X	printf("\nEnter the info filename: ");
X	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
X	    printf("\nInfo filename too long, please re-enter: ");
X	}
X
X	/* compute the basename of the info filename */
X	/* remove the trailing newline */
X	uuname = &infoname[strlen(infoname)-1];
X	*uuname = '\0';
X	/* avoid rindex/shrrchr compat issues, do it by hand */
X	for (--uuname; uuname > infoname; --uuname) {
X	    if (*uuname == '/') {
X		++uuname;
X		break;
X	    }
X	}
X
X	/* attempt to open the info file */
X	infile = fopen(infoname, "r");
X	if (infile == NULL) {
X	    fprintf(stderr, "\n%s: cannot open info file: %s: ",
X		program, infoname);
X	    perror("");
X	    continue;
X	}
X
X	/*
X	 * write the start of the section
X	 */
X	fprintf(output, "---info---\n");
X	check_io(output, oname, EOF_NOT_OK);
X
X	/* uuencode the info file */
X	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);
X
X	printf("\nDo you have another info file to include (enter y or n)? ");
X	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
X	    printf("\nplease answer y or n: ");
X	}
X    };
X    return;
X}
X
X/*
X * output_build - output the ---build--- section
X *
X * Read the needed information from stdin, and write the build section.
X */
Xvoid
Xoutput_build(output, oname, build, bname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X    FILE *build;		/* open build file stream */
X    char *bname;		/* name of the build file */
X{
X    /*
X     * write the start of the section
X     */
X    fprintf(output, "---build---\n");
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * uuencode the program file
X     */
X    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
X    return;
X}
X
X/*
X * output_program - output the ---program--- section
X *
X * Read the needed information form stdin, and write the program section.
X */
Xvoid
Xoutput_program(output, oname, prog, pname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X    FILE *prog;			/* open program stream */
X    char *pname;		/* name of program file */
X{
X    /*
X     * write the start of the section
X     */
X    fprintf(output, "---program---\n");
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * uuencode the program file
X     */
X    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
X    return;
X}
X
X/*
X * output_end - output the ---end--- section
X *
X * Read the needed information form stdin, and write the 'end section'.
X */
Xvoid
Xoutput_end(output, oname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X{
X    /*
X     * write the final section terminator
X     */
X    fprintf(output, "---end---\n");
X    check_io(output, oname, EOF_NOT_OK);
X    return;
X}
X
X/*
X * get_line - get an answer from stdin
X *
X * This function will flush stdout, in case a prompt is pending, and
X * read in the answer.
X *
X * This function returns 0 if the line is too long, of the length of the
X * line (including the newline) of the line was ok.  This function does
X * not return if ERROR or EOF.
X */
Xint
Xget_line(buf, siz, maxcol)
X    char *buf;			/* input buffer */
X    int siz;			/* length of input, including the newline */
X    int maxcol;			/* max col allowed, 0 => disable check */
X{
X    int length;			/* the length of the input line */
X
X    /* flush terminal output */
X    fflush(stdout);
X
X    /* read the line */
X    if (fgets(buf, siz+1, stdin) == NULL) {
X	/* report the problem */
X	check_io(stdin, "stdin", EOF_NOT_OK);
X    }
X
X    /* look for the newline */
X    length = strlen(buf);
X    if (buf[length-1] != '\n') {
X	int eatchar;		/* the char being eaten */
X
X	/* no newline found, line must be too long, eat the rest of the line */
X	do {
X	    eatchar = fgetc(stdin);
X	} while (eatchar != EOF && eatchar != '\n');
X	check_io(stdin, "stdin", EOF_NOT_OK);
X
X	/* report the situation */
X	return 0;
X    }
X
X    /* watch for long lines, if needed */
X    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
X	/* report the situation */
X	return 0;
X    }
X
X    /* return length */
X    return length;
X}
X
X/*
X * output_till_dot - output a set of lines until '.' by itself is read
X *
X * This routine will read a set of lines until (but not including)
X * a single line with '.' is read.  The format of the output is:
X *
X *	leader:\tfirst line
X *	\tnext line
X *	\tnext line
X *	   ...
X *
X * This routine will not return if I/O error or EOF.
X */
Xvoid
Xoutput_till_dot(output, oname, leader)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X    char *leader;		/* the lead text for the first line */
X{
X    char buf[BUFSIZ+1];		/* input buffer */
X    int count;			/* lines read */
X    int done=FALSE;		/* TRUE => finished reading input */
X
X    /* instruct the user on how to input */
X    printf("\nTo end input, enter a line with a single period.\n");
X
X    /* read lines until '.' or EOF */
X    count = 0;
X    while (!done) {
X	/* issue the prompt */
X	printf("%s\t", (count>0) ? "" : leader);
X	fflush(stdout);
X
X	/* get the line */
X	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
X	    printf("\nline too long, please re-enter:\n\t");
X	    continue;
X	}
X
X	/* note if '.' was read */
X	if (strcmp(buf, ".\n") == 0) {
X	    done = TRUE;
X	}
X
X	/* write line if we read something */
X	if (!done) {
X	    fprintf(output, "%s\t%s", (count++>0) ? "" : leader, buf);
X	    check_io(output, oname, EOF_NOT_OK);
X	}
X    }
X
X    /* if no lines read, at least output something */
X    if (count <= 0) {
X	fprintf(output, "%s\t.\n", leader);
X	check_io(output, oname, EOF_NOT_OK);
X    }
X    return;
X}
X
X/*
X * col_len - determine the highest that a string would reach
X *
X * Given a string, this routine returns that a string would reach
X * if the string were printed at column 1.  Tab stops are assumed
X * to start at 9, 17, 25, 33, ...
X */
Xint
Xcol_len(string)
X    char *string;		/* the string to examine */
X{
X    int col;	/* current column */
X    char *p;	/* current char */
X
X    /* scan the string */
X    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
X	/* note the column shift */
X	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
X    }
X    if (*p == '\n') {
X	--col;
X    }
X
X    /* return the highest column */
X    return col;
X}
X
X/*
X * check_io - check for EOF or I/O error on a stream
X *
X * Does not return if EOF or I/O error.
X */
Xvoid
Xcheck_io(stream, name, eof_ok)
X    FILE *stream;		/* the stream to check */
X    char *name;			/* the name of this stream */
X    int eof_ok;			/* EOF_OK or EOF_NOT_OK */
X{
X    /* test for I/O error */
X    if (ferror(stream)) {
X	fprintf(stderr, "%s: error on %s: ", program, name);
X	perror("");
X	exit(1);
X
X    /* test for EOF */
X    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
X	fprintf(stderr, "%s: EOF on %s\n", program, name);
X	exit(1);
X    }
X    return;
X}
X
X/*
X * uuencode - uuencode a file
X *
X * Perform the uuencoding process identical to the process performed
X * by the uuencode(1) utility.
X *
X * This routine implements the algorithm described in the uuencode(5)
X * 4.3BSD Reno man page.
X */
Xvoid
Xuuencode(output, oname, infile, iname, umode, uname)
X    FILE *output;		/* output file stream */
X    char *oname;		/* output filename */
X    FILE *infile;		/* input file stream */
X    char *iname;		/* input filename */
X    int umode;			/* the mode to put on the uuencode file */
X    char *uname;		/* name to put on the uuencode file */
X{
X    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
X    int read_len;		/* actual number of chars read */
X    int val;			/* 6 bit chunk from buf */
X    char filler='\0';		/* filler uuencode pad text */
X    char *p;
X
X    /*
X     * output the initial uuencode header
X     */
X    fprintf(output, "begin %o %s\n", umode, uname);
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * clear out the input buffer
X     */
X    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
X	*p = '\0';
X    }
X
X    /*
X     * We will process UUENCODE_LEN chars at a time, forming
X     * a single output line each time.
X     */
X    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {
X	
X	/*
X	 * the first character is the length character
X	 */
X	fputc(UUENCODE(read_len), output);
X	check_io(output, oname, EOF_NOT_OK);
X
X	/*
X	 * We will convert 24 bits at a time.  Thus we will convert
X	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
X	 */
X	for (p=buf; read_len>0; read_len-=3, p+=3) {
X
X	    /* bits 0 to 5 */
X	    val = (p[0]>>2)&0x3f;
X	    fputc(UUENCODE(val), output);
X	    check_io(output, oname, EOF_NOT_OK);
X
X	    /* bits 6 to 11 */
X	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
X	    fputc(UUENCODE(val), output);
X	    check_io(output, oname, EOF_NOT_OK);
X
X	    /* bits 12 to 17 */
X	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
X	    fputc(UUENCODE(val), output);
X	    check_io(output, oname, EOF_NOT_OK);
X
X	    /* bits 18 to 23 */
X	    val = p[2]&0x3f;
X	    fputc(UUENCODE(val), output);
X	    check_io(output, oname, EOF_NOT_OK);
X	}
X
X	/* end of UUENCODE_LEN line */
X	fputc('\n', output);
X	check_io(output, oname, EOF_NOT_OK);
X
X	/*
X	 * clear out the input buffer  (don't depend on bzero() or memset())
X	 */
X	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
X	    *p = '\0';
X	}
X    }
X
X    /* check the last read on the input file */
X    check_io(infile, iname, EOF_OK);
X
X    /* write end of uuencode file */
X    fprintf(output, "%c\nend\n", UUENCODE(filler));
X    check_io(output, oname, EOF_NOT_OK);
X}
SHAR_EOF
chmod 0444 mkentry.c ||
echo "restore of mkentry.c failed"
set `wc -c mkentry.c`;Wc_c=$1
if test "$Wc_c" != "33961"; then
	echo original size 33961, current size $Wc_c
fi
# ============= obfuscate.info ==============
echo "x - extracting obfuscate.info (Text)"
sed 's/^X//' << 'SHAR_EOF' > obfuscate.info &&
X1993 Obfuscated contest information
X
XCopyright (c) Landon Curt Noll & Larry Bassel, 1993.  
XAll Rights Reserved.  Permission for personal, education or non-profit use is 
Xgranted provided this this copyright and notice are included in its entirety 
Xand remains unaltered.  All other uses must receive prior permission in writing 
Xfrom both Landon Curt Noll and Larry Bassel.
X
XThe International Obfuscated C Code Contest (IOCCC), in the sprit of
Xco-operation, is willing mention other programming contents, as space
Xpermits.  
X
XHow to have your contest included in this file:
X
X    If you wish the IOCCC judges to include your contest in this file,
X    send a request to:
X
X	judges@toad.com
X
X    We request that contest descriptions be limited to 50 lines and to
X    not exceed 2500 bytes.  We typically request that your contest
X    include a current description of the IOCCC.
X
X    In order to be included in this file for given year, we must
X    receive a current description no EARLIER than Jan 1 00:00:00 UTC and
X    no LATER than Feb 15 00:00:00 UTC.  Agreement to publish your
X    contest must also be obtained prior to Feb 15.  Annual contests
X    that fail to submit a new entry will be dropped from this file.
X
XOfficial Disclaimer:  (pardon the officialese)
X
X    The contents noted below, other than the IOCCC, are not affiliated 
X    with the IOCCC, nor are they endorsed by the IOCCC.  We reserve the 
X    right to refuse to print information about a given contest.
X
X    The information below was provided by the particular contest
X    organizer(s) and printed by permission.  Please contact the
X    contest organizer(s) directly regarding their contents.
X
XWith that official notice given, we present for your ENJOYMENT, the following
Xinformation about contents:
X
X---------------------------------------------------------------------------
X
X    10th International Obfuscated C Contest   
X    
X	"The original obfuscated contest"
X
X    Obfuscate:  tr.v.  -cated, -cating, -cates.  1. a.  To render obscure.
X                b.  To darken.  2. To confuse:  Their emotions obfuscated 
X		their judgment.  [LLat. obfuscare, to darken : ob(intensive) +
X                Lat. fuscare, to darken < fuscus, dark.] -obfuscation n.
X                obfuscatory adj.
X 
X    GOALS OF THE CONTEST:
X 
X        * To write the most Obscure/Obfuscated C program under the rules below.
X        * To show the importance of programming style, in an ironic way.
X        * To stress C compilers with unusual code.
X        * To illustrate some of the subtleties of the C language.
X        * To provide a safe forum for poor C code.  :-)
X 
X    The IOCCC is the grandfather of USENET programming contests.  Since
X    1984, this contest demonstrated that a program that mearly works
X    correctly is not sufficient.  The IOCCC has also done much to add
X    the arcane word 'obfuscated' back into the English language.
X    (see "The New Hacker's Dictionary" by Eric Raymond)
X 
X    You are strongly encouraged to read the new contest rules before
X    sending any entries.  The rules, and sometimes the contest Email
X    address itself, change over time.  A valid entry one year may
X    be rejected in a later year due to changes in the rules.  The typical
X    start date for contests is in early March.  Contest rules are normally not
X    finalized and posted until the beginning of the contest.  The typical 
X    closing date for contests are in early May.
X 
X    The contest rules are posted to comp.unix.wizards, comp.lang.c,
X    misc.misc, alt.sources and comp.sources.d.  If you do not have access 
X    to these groups, or if you missed the early March posting, you may 
X    request a copy from the judges, via Email, at;
X 
X        judges@toad.com   -or-   ...!{sun,uunet,utzoo,pyramid}!hoptoad!judges
X 
X    Previous contest winners are available via anonymous ftp from
X    ftp.uu.net under the directory /pub/ioccc.
X
X---------------------------------------------------------------------------
X
X    0th International Obfuscated Perl Contest
X	By: Landon Noll & Larry Wall
X
X    This content is being planned.  Someday when Landon & Larry are not too 
X    busy, they will actually get around to posting the first set of rules!
X
X    Landon says: "Yes, I know that I said we would have a contest in 1993,
X		  but other existing projects got in the way.  Hopefully
X		  something will be developed after Nov 1993."
X
X---------------------------------------------------------------------------
X
X                2nd International obFUsCaTeD POsTsCripT Contest
X                     Jonathan Monsarrat (jgm@cs.brown.edu)
X                         Alena Lacova (alena@nikhef.nl)
X
X    A  contest of  programming skills  and  knowledge, exclusively  for the
X    PostScript programming language. Its purpose:
X
X    * To spread knowledge of PostScript and its details.
X    * To applaud those with the best tricks.
X    * To prove  that humans can  beat those damnable  machine generators at
X      their own game by writing  the most obscure and mysterious PostScript
X      programs ever.
X
X    Winners will receive the fame and attention that goes with having their
X    program entry posted as a winner to programmers world-wide.
X
X    The 1993 contest rules and results are available by ftp as
X    ``wilma.cs.brown.edu:pub/postscript/obfuscated*.shar'', or individually
X    in the obfuscated directory. The judges will post the 1994 rules
X    in November to comp.lang.postscript on Usenet, and other places.
X    Send questions to jgm@cs.brown.edu.
X
X    Categories include: Best Obfuscated PostScript, Best Artwork,
X    Most Compact, Best Interactive Program, Most Useful, and
X    anything so unusual and creative that it deserves an award.
X
X    The judges will choose the winners of each category.
X
X    Alena Lacova  is a system  administrator at NIKHEF  (Institute for High
X    Energy and Nuclear  Physics) in the  Netherlands. She is  the author of
X    The PostScript Chaos  Programs, which draw  Julia sets, Mandelbrot sets
X    and other kinds of fractal functions.
X
X    Jonathan Monsarrat is a graduate  student from MIT and Brown University
X    in  the  U.S.A. He  is  the  FAQ maintainer  for  the  Usenet newsgroup
X    comp.lang.postscript and the author of The PostScript Zone and LameTeX.
X .
X
SHAR_EOF
chmod 0444 obfuscate.info ||
echo "restore of obfuscate.info failed"
set `wc -c obfuscate.info`;Wc_c=$1
if test "$Wc_c" != "6257"; then
	echo original size 6257, current size $Wc_c
fi
exit 0
-- 
Sunnyvale residents: Vote Landon Noll for Sunnyvale City Council seat 1.
Xref: cantaloupe.srv.cs.cmu.edu comp.windows.x.i386unix:1136 comp.unix.pc-clone.32bit:2407 comp.unix.bsd:13288 comp.windows.x:66189 comp.answers:363 news.answers:7124
Path: cantaloupe.srv.cs.cmu.edu!das-news.harvard.edu!ogicse!uwm.edu!zaphod.mps.ohio-state.edu!cs.utexas.edu!utnut!skule.ecf!steve
From: steve@ecf.toronto.edu (Steve Kotsopoulos)
Newsgroups: comp.windows.x.i386unix,comp.unix.pc-clone.32bit,comp.unix.bsd,comp.windows.x,comp.answers,news.answers
Subject: X on Intel-based Unix Frequently Asked Questions [FAQ]
Summary: X options for Intel-based Unix (SYSV/386, 386BSD, Linux, Mach)
Message-ID: <C4rI7o.4Bw@ecf.toronto.edu>
Date: 31 Mar 93 16:38:08 GMT
Article-I.D.: ecf.C4rI7o.4Bw
Expires: Sat, 1 May 1993 04:00:00 GMT
Sender: steve@ecf.toronto.edu (Steve Kotsopoulos)
Reply-To: steve@ecf.toronto.edu
Followup-To: poster
Organization: University of Toronto, Engineering Computing Facility
Lines: 530
Approved: news-answers-request@MIT.Edu

Archive-name: Intel-Unix-X-faq
Last-modified: 30 Mar 1993

Note: This is a major re-organization (and replacement) of my
      "Frequently Asked Questions About X386" FAQ list.

This article includes answers to:

I) What options do I have for X software on my Intel-based Unix system?
	1. Free options
	2. Commercial options
II) What is XFree86 and where do I get it?
	3. What is XFree86?
	4. What OSs are supported?
	5. What video hardware is supported?
	6. What about accelerated boards?
	7. Why doesn't XFree86 support 16-color VGA modes?
	8. What other hardware or software requirements are there?
	9. Where can I get source for XFree86?
	10. Where can I get binaries for XFree86?
IV) What general things should I know about running XFree86?
	11. Installation directories
	12. Configuration files
	13. Determining VGA dot clocks and monitor modes
	14. Rebuilding/reconfiguring the server from the link kit
V) What OS-specific things should I know about running XFree86?
	15. SVR4
	16. SVR3
	17. 386BSD
	18. Linux
	19. Mach
VI) What things should I know for building XFree86 from source?
VII) Is there anything special about building clients with XFree86?
	20. BSD compatibility library
	21. ANSICCOPTIONS

This article does NOT include answers to general X questions, since these
are already covered by the X FAQ that is regularly posted by David B. Lewis
<faq%craft@uunet.uu.net>.

If you have anything to add or change on the FAQ just let me know.
(especially if you had a problem that someone else was able to help you with)
Send changes to steve@ecf.toronto.edu, please put 'FAQ' somewhere
in the subject line so that my mail filter will put it in the correct
mail folder.

Please DO NOT ask me questions that are not answered in the FAQ.  I do not
have time to respond to these individually.  Instead, post your question
to the net, and send me the question and answer together when you get it.

Frequently Asked Questions About X on Intel-based Unix (with answers)
=====================================================================

I) What options do I have for X software on my Intel-based Unix system?

1. Free options
	The BEST option is XFree86, which is an enhanced version of X386 1.2.
	Any other version of X386 will have slower performance, and will
	be more difficult to compile.  Information on how to obtain XFree86
	is listed below.

	X386 is the port of the X11 server to System V/386 that was
	done by Thomas Roell (roell@sgcs.com).
	It supports a wide variety of SVGA boards.
	There are 2 major free versions: X386 1.1 is based on X11R4,
	X386 1.2 is included in MIT's X11R5 distribution (ie. you
	don't need to patch it into the MIT source any more).
	X386 1.3 is the current commercial offering from SGCS (see below).

2. Commercial options

     1) Metro Link
	2213 W. McNab Road
	Pompano Beach, FL  33069
	(305) 970-7353
	Fax: (305) 970-7351
	email: sales@metrolink.com

	Summary: OS:    QNX, SVR3, SVR4.[012], SCO, UnixWare, LynxOS, 
			DESQview/X, Venix, ISC, Solaris, Pyramid, SunOS
		 HW:    EGA, VGA, SVGA, TIGA, TARGA, 8514/A, Mach, 
			S3, WD, Fujistu, Matrox, Microfield Graphics, R33020
		 Other: Motif, OpenLook/XView, XIE Imaging Extension,
			Xv Video Extension, Audio Drivers, Multi Media

     2) SGCS (Snitily Graphics Consulting Services)
	894 Brookgrove Lane
	Cupertino, CA  95014
	(800) 645-5501, (408) 255-9665
	Fax: (408) 255-9740
	email: info@sgcs.com  or ...!mips!zok!info

	Summary: OS: SVR3.2, SVR4 
		 HW: 8514/A (ATI Ultra), S3 (Diamond Stealth), SVGA
		 Other: Motif, Dual-headed server

     3) Consensys Corporation
	1301 Pat Booker Rd.
	Universal City, TX 78148
	Phone: 1-800-388-1896
	FAX:   1-416-940-2903
	email: info@consensys.com

	Summary: OS: Consensys V4.2, Consensys' version of
		     Unix System V Release 4.2
		 HW: X11R4 server support for VGA, SVGA
		 Other: MoOLIT, Motif, X11R5 Clients

     4) The Santa Cruz Operation, Inc.
	p.o. box 1900
	Santa Cruz, California 95061
	(408) 425 7222, (800) SCO UNIX,
	FAX: (408) 458 4227
	email: info@sco.com

	Summary: OS: ODT 1.1, ODT 2.0, SCO Unix 3.2v4
		 HW: X11R4 server support for SVGA, 8514/A, S3, TMS340x0,
		     WD90C31, XGA2, assorted local bus (see SCO Hardware
		     Compatabilty Guide for actual card vendors).
		 Other: Motif	

     5) Answer Software & Consulting
	p.o. box 14171
	Columbus, Ohio 43214
	614-263-XLAB
	email: sales@x4coher.com

	Summary: OS: Coherent 4.0.1r72 or greater
		 HW: works with any VESA compliant video

  NOTE: Other commercial vendors (including OS vendors describing
	bundled software) are welcome to submit summary information
	summary information such as the above.

II) What is XFree86 and where do I get it?

3. What is XFree86?

   XFree86 is an enhanced version of X386 1.2, which was distributed with
   X11R5.  This release consists of many bug fixes, speed improvements, and
   other enhancements.  Here are the highlights of the enhancements:

    1) The SpeedUp package from Glenn Lai is an integral part of XFree86,
       selectable at run-time via the Xconfig file.  Some SpeedUps require
       an ET4000 based SVGA, and others require a virtual screen width of
       1024.  The SpeedUps suitable to the configuration are selected by
       default.  With a high-quality ET4000 board (VRAM), this can yield
       up to 40% improvement of the xStones benchmark over X386 1.2.
    2) The fX386 packages from Jim Tsillas are included as the default
       operating mode if SpeedUp is not selected.  This mode is now
       equivalent in performance to X386 1.1b (X11R4), and approximately
       20% faster than X386 1.2.
    3) Support for LOCALCONN, compile-time selectable for server, clients,
       or both.  This support is for both SVR3.2 and SVR4.  For SVR4.0.4
       with the 'Advanced Compatibility Package', local connections from
       SCO XSight/ODT clients are supported.
    4) Drivers for ATI and Trident TVGA8900C and TVGA9000 SVGA chipsets.
       Refer to the files README.ati and README.trident for details about
       the ATI and Trident drivers.
    5) Support for compressed bitmap fonts has been added (Thomas Eberhardt's
       code from the contrib directory on export.lcs.mit.edu).
    6) Type1 Font code from MIT contrib tape has been included, and is
       compile-time selectable.  There are contributed Type1 fonts in the
       contrib directory on export.lcs.mit.edu.
    7) New configuration method which allows the server's drivers and font
       renderers to be reconfigured from both source and binary
       distributions.
    8) Integrated support for 386BSD, Mach, and Linux.
    9) A monochrome version of the server which will run on generic VGA
       cards is now included.

   The following key features were added with the release of XFree86 1.2
   (they were not in XFree86 1.1):

    1) The monochrome server has been enhanced to do bank-switching of
       available SVGA memory to allow virtual screens up to 1600x1200 
       (see the X386(1) manual page for more information).
    2) Support for the Hercules mono card has been added to the
       monochrome server, and with it the ability to support a "two
       headed" server - one VGA, and one Hercules.  So far this has only
       been tested on SVR4 (it is also reported to work under Linux).
    3) SVR3 shared libraries, tested under ISC SVR3 2.2 and 3.0.1.
    4) Support for SVR4.2 (There are some special considerations to
       consider, due to new USL bugs; see the README.SVR4 file for
       more information.)
    5) Support for PS/2 mice, and Logitech MouseMan/TrackMan (some 
       versions of these devices were not previously compatible).
    6) A new tutorial on how to develop correct video card and monitor
       timing data, written by Eric Raymond (derived from previous
       documentation and a lot of experimentation).
    7) Greatly improved support for international keyboards, including
       implementation of the Compose key functionality found on many 
       vendor servers (see the X386keybd(1) manual page for more 
       information).
    8) The accuracy with which the server detects SVGA pixel clocks has
       been improved, and the timings are now stored at accuracies of
       0.1 MHz.  Users may want to consider removing an existing Clocks
       line from their Xconfig file and re-probing using the new server.
    9) Many enhancements in error handling and parsing of the Xconfig
       configuration file.  Error messages are much more informative
       and intuitive, and more validation is done.  There are many new
       options that can be enabled in the Xconfig file (see the X386(1) 
       manual page for more information on the format of this file).

       Plus a number of other small things.  Refer to the CHANGELOG file
       in the source distribution for full details.

   Also included are a tutorial on monitor timing by Eric Raymond, and the
   current X386 mode database and a sample xdm configuration by David Wexelblat.

4. What OSs are supported?

    XFree86 supports:
	SVR4.2: Consensys V4.2
	SVR4.0: Microport, Dell, Esix, ISC, AT&T, MST, Consensys, UHC
	SVR3: ISC 2.2 & 3.0, AT&T 2.2
	Linux, Mach 386, 386BSD 0.1

	BSD/386 is not supported, but it should work. The most active
	BSD/386 person is Greg Lehey <grog@lemis.de>.

	Note that Esix 3.2D and SCO are not supported yet,
	but anyone should feel free to submit patches.
	If you are interested in tackling this, send mail to
	xfree86@physics.su.oz.au

5. What video hardware is supported?

   At this time, XFree86 1.2 supports the following SVGA chipsets:

	Tseng ET4000
	Tseng ET3000
	Paradise PVGA1
	Western Digital WD90C00, WD90C10, WD90C11 (these are supersets of
		the PVGA1, and use its driver)
	Genoa GVGA
	Trident TVGA8900C, TVGA9000
	ATI 18800, 28800

	All of the above are supported in both 256 color and monochrome modes,
	with the exception of the ATI chipsets, which are only supported in
	256 color mode.

	The monochrome server also supports generic VGA cards, using 64k of
	video memory in a single bank, and the Hercules card.  On the
	ET3000, only 64k of video memory is supported for the monochrome
	server, and the GVGA has not been tested with more than 64k.

	It appears that some of the SVGA card manufacturers are going to
	non-traditional mechanisms for selecting pixel-clock frequencies.  To
	avoid having to modify the server to accommodate these schemes XFree86
	1.2 adds support for using an external program to select the pixel
	clock.  This allows programs to be written as new mechanisms are
	discovered.  Refer to the README.clkprog file for information on how
	these programs work, if you need to write one.  If you do develop such
	a program, the XFree86 team would be interested in including it with
	future XFree86 releases.

	If you are purchasing new hardware for the purpose of using XFree86,
	it is suggested that you purchase an ET4000-based board such as the
	Orchid ProDesigner IIs.  Avoid recent Diamond boards; XFree86 will not
	work with them, because Diamond won't provide programming details.
	In fact, the XFree86 project is actively not supporting new Diamond
	products, as long as such policies remain in effect.  Contributions
	of code will NOT be accepted (because of the potential liabilities).
	If you would like to see this change, tell Diamond about it.

	Some people have asked if XFree86 would work with local bus or EISA
	video cards. Theoretically, the means of communication between the
	CPU and the video card is irrelevant to Xfree86 compatibility. It
	could be ISA, EISA, or local bus.  What should matter is the chipset
	on the video card.  Unfortunately, the developers don't have a lot
	of access to EISA or VLB machines, so this is largely an untested
	theory.  However, we have yet to see any reports of things not
	working on one of these buses and we have several reports of Xfree86
	working fine on them.

6. What about accelerated boards?

	At this time, there is no support in XFree86 for accelerated boards
	like the S3, ATI Ultra (8514/A), TIGA, etc.  This support is available
	in commercial products from SGCS and MetroLink (for SVR3 and SVR4).

	An S3 server is available for 386BSD and Linux.  Contact
	<hasty@netcom.com> for 386BSD or <jon@robots.ox.ac.uk> for Linux.

	A beta 8514/A server is available for Linux. Contact <martin@cs.unc.edu>
	or <jon@robots.ox.ac.uk>. Note: these servers are NOT part of XFree86.

7. Why doesn't XFree86 support 16-color VGA modes?

	The reason that this is not supported is the way VGA implements the
	16-color modes.  In 256-color modes, each byte of frame buffer memory
	contains 1 pixel.  But the 16-color modes are implemented as bit-
	planes.  Each byte of frame- buffer memory contains 1 bit from each
	of each of 8 pixels, and there are four such planes.  The MIT frame-
	buffer code is not designed to deal with this.  If VGA handled
	16-color modes by packing 2 4-bit pixels into each byte, the MIT code
	could be modified to support this (or it already may; I'm not sure).
	But for the VGA way of doing things, a complete new frame-buffer
	implementation is required.  Some beta testers are looking into this,
	but nothing is yet available from the project.

8. What other hardware or software requirements are there?

	Obviously, a supported SVGA board and OS are required.  To run
	X efficiently, 12-16MB of memory should be considered a minimum.
	The various binary releases take 10-40MB of disk space, depending
	on the OS (e.g. whether or not it supports shared libraries).
	To build from sources, at least 80MB of free disk space will
	be required, although 120MB should be considered a comfortable 
	lower bound.

9. Where can I get source for XFree86?

	Source patches for the current version (1.2, based on X11R5 PL22
	from MIT), are available via anonymous FTP from:
		export.lcs.mit.edu (under /contrib/XFree86)
		ftp.physics.su.oz.au (under /XFree86)
		ftp.win.tue.nl (under /pub/XFree86)
	(For the rest of this FAQ, these 3 location will be called $FTP)

	Refer to the README file under the specified directory for information
	on which files you need to get to build your distribution.

10. Where can I get binaries for XFree86?

	Binaries are available via anonymous FTP from:
		ftp.physics.su.oz.au		- SVR4 binaries
			under /XFree86/SVR4
		ftp.win.tue.nl			- SVR4 binaries
			under /pub/XFree86/SVR4
		ferkel.ucsb.edu			- SVR4 binaries
			under /pub/SVR4/XFree86
		stasi.bradley.edu		- SVR4 binaries
			under /pub/XFree86/SVR4
		blancmange.ma.utexas.edu	- SVR3 (ISC) binaries
			under /pub/ISC
		ftp.prz.tu-berlin.de            - SVR3 (ISC) binaries
			under /pub/pc/isc/XFree86
		tsx-11.mit.edu			- Linux binaries
			under /pub/linux/packages/X11
		agate.berkeley.edu		- 386BSD binaries
			under /pub/386BSD/0.1-ports/XFree86
		ftp.cs.uwm.edu			- Mach binaries
			under /i386

	Ensure that you are getting XFree86 1.2 - some of these sites may
	archive older releases as well.  Each binary distribution will
	contain a README file that describes what files you need to take
	from the archive, and which compile-time option selections were
	made when building the distribution.

IV) What general things should I know about running XFree86?

11. Installation directories

	The top-level installation directory is specified by the ProjectRoot
	(/usr/X386, by default) variable in config/site.def. Binaries, include
	files, and libraries are installed in $ProjectRoot/{bin,include,lib}.

	This can be changed when rebuilding from sources, and can be modified
	via symbolic links for those OSs that support them. This directory is
	nonstandard, and was chosen this way to allow XFree86 to be installed
	alongside a commercial/vendor-supplied X implementation.

12. Configuration files

	The XFree86 server reads a configuration file ("Xconfig") on startup.
	The search path, contents and syntax for this file are documented in
	the server manpage, which should be consulted before asking questions.

13. Determining VGA dot clocks and monitor modes

	David E Wexelblat (dwex@mtgzfs3.att.com) maintains a database of known
	clock settings for VGA cards and monitor settings.
	The database is installed in /usr/X386/lib/X11/etc/modeDB.txt, and
	is in the source tree under mit/server/ddx/x386/etc. This database is
	also available from him (for the latest copy), and is kept on
	export.lcs.mit.edu in ~/contrib/X386.modeDB.Z, which is updated
	occasionally.  Obtain a copy of this database.  It just might have the
	settings you need.  If you create new settings, please send them to
	David for inclusion in the database.

	If this doesn't help you, the VideoModes.doc (by Eric Raymond) file 
	with XFree86 contains tutorials on how to come up with these timings.
	It may be helpful to start with settings that almost work, and use
	this description to get them right.  When you do, send the information
	to David Wexelblat for inclusion in the database.

	NOTE: The old 'clock.exe' program is not supported any more, and
	      is completely unnecessary.  If you need to determine dot
	      clock values for a new board, remove the 'Clocks' line from
	      your Xconfig file (if present), and start the server.  The
	      server will probe for clocks itself and print them out.
	      You can use these values to put a 'Clocks' line into your
	      Xconfig file, which is not necessary, but will speed up
	      starting the server in the future.

14. Rebuilding/reconfiguring the server from the link kit

	If you have installed the server Binary Link Kit, it is possible to
	reconfigure the drivers and font renderers in the server.  This is
	fully explained in the README file that is available with the link kit.

V) What OS-specific things should I know about running XFree86?

	First of all, the server must be installed suid-root (mode 4755).

15. SVR4
	Why won't my xterm run properly?

	If your kernel is not built with the consem module, you should define
	CONSEM=no in you environment. Otherwise xterm won't run.
	csh users should use 'setenv CONSEM no'

	The Esix console driver patch 403019 is known to cause keymapping
	problems with XFree86.  It recommended that this patch not be
	installed.  Alternatively they keymap can be fixed with xmodmap.

16. SVR3

	Make sure you look at $FTP/README.ISC, if that's what you are running.

17. 386BSD

	Make sure you look at $FTP/README.386BSD.

	Also, a separate 386BSD FAQ is maintained by Richard Murphey
	<Rich@Rice.edu>.  The latest version should be available in the
	file XFree86-1.2-386BSD-FAQ at the following ftp sites:

	    agate.berkeley.edu:/pub/386BSD/0.1-ports/XFree86-1.2
	    wuarchive.wustl.edu:/mirrors4/386bsd/0.1-ports/XFree86-1.2
	    grasp1.univ-lyon1.fr:pub/386BSD/0.1-ports/XFree86-1.2

18. Linux

	You must be running Linux 0.97pl4 or greater, and have the 4.1 gcc
	jump libraries installed.

	Make sure the binaries X386, X386mono, xload and xterm are setuid root.

	If your kernel doesn't have TCP support compiled in, you'll have to
	run the server as "X -pn". The default startup configuration assumes
	that TCP is not available. If it is, change the two files
	/usr/X386/bin/startx and /usr/X386/lib/X11/xdm/Xservers, removing the
	-pn argument to X386.

	Make sure /dev/console is either a link to /dev/tty0 or has the major
	number 4, minor number 0. Also note that if /dev/console is not
	owned by the user running X, then xconsole and xterm will not permit
	console output redirection. Xdm will properly change the owner, but
	startx won't.

	When running xdm from rc.local, you will need to provide it with
	a tty, for example "xdm < /dev/console &".

	For more detailed information, please read the file README present
	with the distribution on tsx-11.mit.edu.

19. Mach

	Make sure you look at $FTP/README.Mach.

VI) What things should I know for building XFree86 from source?

	This section has been removed from the FAQ, since it is
	fully explained in $FTP/README and the OS-specific READMEs.
	Please look at those files for information on building XFree86.

VII) Is there anything special about building clients with XFree86?

20. BSD compatibility library

	A lot of clients make use of BSD functions like bcopy(), etc.
	The default configuration files are set up to link with libXbsd.a
	which contains emulation for bcopy(), bzero(), bcmp(), ffs(), random(),
	seed(). A better way of providing the 'b' functions is to include
	<X11/Xfuncs.h> in source files that call them.  Xfuncs.h provides macro
	definitions for these in terms of the SYSV 'mem' functions.  If you are
	linking with a vendor supplied library which calls some of these
	functions, then you should link with libXbsd.a

21. ANSICCOPTIONS

	This is something that was added to allow a developer to get rid of the
	ANSI-ness defined in the default CCOPTIONS without having to rewrite
	the entire CCOPTIONS line.  For example, with stock MIT, you'd see
	something like
		CCOPTIONS="-ansi -O2 -fwritable-strings"
	and to get rid of the ANSI-ness, the developer would have to put
		CCOPTIONS="-O2 -fwritable-strings"
	in his Imakefile.  With this change, you would see a default of
		ANSICCOPTIONS="-ansi"
		CCOPTIONS="-O2 -fwritable-strings"
	and all the developer would have to put in the Imakefile is:
		ANSICCOPTIONS=
	to get rid of the ANSI-ness (many X clients will die a horrible death
	with -ansi).  The effect is even more dramatic in practice, because
	CCOPTIONS is actually quite complex.  The other issue is that one must
	add 'ANSICCOPTIONS=$(ANSICCOPTIONS)' to a PassCDebugFlags definition.

XFree86 Contact Information

    Ongoing development planning and support is coordinated by the XFree86
    Core Team.  At this time the Core Team consists of:

	The original "gang of four":
		David Dawes <dawes@physics.su.oz.au>
		Glenn Lai <glenn@cs.utexas.edu>
		Jim Tsillas <jtsilla@damon.ccs.northeastern.edu>
		David Wexelblat <dwex@mtgzfs3.att.com>

	Those supporting non-SYSV operating systems:
		Robert Baron <Robert.Baron@ernst.mach.cs.cmu.edu> [Mach]
		Rich Murphey <Rich@Rice.edu> [386BSD]
		Orest Zborowski <obz@kodak.com> [Linux]

    e-mail sent to <xfree86@physics.su.oz.au> will reach all of the core team.

	--------------------------------------------------

Thanks to all the people who already sent me corrections or additions,
especially David Wexelblat (one of the major contributors of updates).
-- 
Steve Kotsopoulos  P.Eng.           mail:   steve@ecf.toronto.edu
Systems Analyst                     bitnet: steve@ecf.UTORONTO.BITNET
Engineering Computing Facility      uucp:   uunet!utai!ecf!steve
University of Toronto               phone:  (416) 978-5898

Xref: cantaloupe.srv.cs.cmu.edu comp.windows.x.intrinsics:1089 comp.windows.x:66322 comp.answers:381 news.answers:7245
Path: cantaloupe.srv.cs.cmu.edu!crabapple.srv.cs.cmu.edu!bb3.andrew.cmu.edu!news.sei.cmu.edu!cis.ohio-state.edu!bounce-bounce
From: ware@cis.ohio-state.edu (Peter Ware)
Newsgroups: comp.windows.x.intrinsics,comp.windows.x,comp.answers,news.answers
Subject: comp.windows.x.intrinsics Frequently Asked Questions (FAQ)
Supersedes: <FAQ-Xt_728840923@oboe.cis.ohio-state.edu>
Followup-To: comp.windows.x.intrinsics
Date: 2 Apr 1993 12:42:01 -0500
Organization: The Ohio State University Dept. of Computer and Info. Science
Lines: 1609
Approved: news-answers-request@MIT.Edu
Expires: 14 May 1993 17:41:53 GMT
Message-ID: <FAQ-Xt_733772513@oboe.cis.ohio-state.edu>
Reply-To: ware@cis.ohio-state.edu
NNTP-Posting-Host: oboe.cis.ohio-state.edu
Summary: Answers about the X11 Window System widgets and Xt Intrinsics library

Archive-name: Xt-FAQ
Version: $Id: FAQ-Xt,v 1.28 93/04/02 12:41:12 ware Exp $

		    The X Toolkit Intrinsics F.A.Q
			  A monthly posting


This article contains the answers to some Frequently Asked Questions
(FAQ) from comp.windows.x about the X Toolkit Intrinsics.  To submit
questions (preferably with an answer) send email to: ware@cis.ohio-state.edu

Many FAQs, including this one, are available on the archive site
rtfm.mit.edu in the directory pub/usenet/news.answers.  The name
under which a FAQ is archived appears in the Archive-name 
line at the top of the article.  This FAQ is archived as Xt-FAQ.

All code fragments are public domain.  

			       Contents
0.  Xt Glossary
1.  Software Versions
2.  Related FAQ's
3.  Why does my application core dump when I use signals/alarms/cthreads?
4.  How do I use a different visual than the default?
5.  Which visual should an application use?
6.  Why do only Shell widgets have a Visual?
7.  Which visual, depth and colormap do Shells inherit?
8.  I've done all the above and I still get a BadMatch error.  Why?
9.  Why doesn't my widget get destroyed when I call XtDestroyWidget()?
10. How do I exit but still execute the DestroyCallbacks?
11. How do I resize a Shell widget?
12. Why can't XtAppAddInput() handle files?
13. What good books and magazines are there on Xt?
14. What Widgets are available?
15. What alternatives to the Intrinsics are there?
16. How do I pass a float value to XtSetValues?
17. How do I write a resource converter?
18. How do I open multiple displays?
19. What changed from R3 to R4 to R5?
20. Where are the resources loaded from?
21. What order are callbacks executed in?
22. How do I know if a widget is visible?
23. How do I reparent a widget in Xt, i.e. XtReparentWidget()?
24. Why use XtMalloc, XtFree, etc?
25. How to debug an Xt application?
26. Why don't XtAddInput(), XtAddTimeout() and XtAddWorkProc() work?
27. What is and how can I implement drag and drop?

----------------------------------------------------------------------
0.  Xt Glossary
----------------------------------------------------------------------

o The Xt Intrinsics implement an object oriented interface to C code
  to allow useful graphical components to be created.  Included with
  this are classes that provide the base functionality: Object,
  RectObj, Core, Composite, Constraint, Shell, OverrideShell, WMShell,
  etc.  The terms "Xt" and "Intrinsics" are used interchangeably,
  however, they are used very precisely to mean a specific library of the X
  window system.  In particular, it does not include the Athena,
  Motif, OLIT or any other widget set.  Without further widgets the
  Intrinsics are not especially useful.

o A widget refers to a user interface abstraction created via Xt.  The
  precise use, is any object that is a subclass of the Core class.  It
  is used loosely to refer to anything that is a subclass of the
  Object class although these are more accurately called windowless
  widgets or gadgets.

o Xlib is the C interface to the X11 protocol.  It is one layer below
  the Xt Intrinsics.  Typically a widget uses relatively few Xlib
  functions because Xt provides most such services although an
  understanding of Xlib helps with problems.

----------------------------------------------------------------------
1.  Software Versions
----------------------------------------------------------------------

The following are the latest versions of Xt based software:
        _____________________________________________________________
	Software	Version		Released	Next Expected
        _____________________________________________________________
	X11R4		patch 18			(none)
	X11R5		patch 21	12/18/92	??
	Athena Widgets	(see X11R5)
	Motif		1.2.1		9/92		??
	OLIT		??		??		??
	Xtra		2.5		6/15/92		??
	Xw		X11R4				(none)
	Xcu		X11R5				(none)
	fwf		3.4		1/11/92		4/93
        _____________________________________________________________

----------------------------------------------------------------------
2.  Related FAQ's
----------------------------------------------------------------------
David B. Lewis (uunet!craft!faq) maintains the FAQ on X.  It
is posted monthly on comp.windows.x and located on export in contrib/FAQ.

Liam R. E. Quin (lee@sq.sq.com) posts an FAQ list on Open Look to 
comp.windows.x.  

Jan Newmarch (jan@pandonia.canberra.edu.au) posts an FAQ list on Motif 
to comp.windows.x.motif.

Peter Ware (ware@cis.ohio-state.edu) posts an FAQ list for
comp.windows.x.intrinsics; it is on export in contrib/FAQ-Xt.

----------------------------------------------------------------------
3.  Why does my application core dump when I use signals/alarms/cthreads?
----------------------------------------------------------------------

In brief, Xlib, Xt and most widget sets have no mutual exclusion for
critical sections.  Any interrupt handler is likely to leave one of
the above libraries in an inconsistent state -- such as all the
appropriate flags not yet set, dangling pointers, in the middle of a
list traversal, etc.  Note that the ANSI C standard points out that
behavior of a signal handler is undefined if the signal handler calls
any function other than signal() itself, so this is not a problem
specific to Xlib and Xt; the POSIX specification mentions other
functions which may be called safely but it may not be assumed that
these functions are called by Xlib or Xt functions.

The only safe way to deal with signals is to set a flag in the
interrupt handler.  This flag later needs to be checked either by a
work procedure or a timeout callback.  It is incorrect to add either
of these in the interrupt handler.  As another note, it is dangerous
to add a work procedure that never finishes.  This effectively
preempts any work procedures previously added and so they will never
be called.  Another option is to open a pipe, tell the event loop
about the read end using XtAppAddInput() and then the signal handler
can write a byte to the write end of the pipe for each signal.
However, this could deadlock your process if the pipe fills up.

Why don't the Intrinsics deal with this problem?  Primarily because it
is supposed to be a portable layer to any hardware and operating
system.   Is that a good enough reason -- I don't think so.

        Note: the article in The X Journal 1:4 and the example in O'Reilly
Volume 6 are in error.

----------------------------------------------------------------------
4.  How do I use a different visual than the default?
----------------------------------------------------------------------

This requires a more complicated answer than it should.  A window has
three things that are visual specific -- the visual, colormap and
border pixmap.  All widgets have their own Colormap and BorderPixmap
resource; only shell widgets have Visual resources (another questions
deals with why shells have a Visual).  The default value of these
resources is CopyFromParent which does exactly what it says.  In the
shell widget CopyFromParent gets evalulated as DefaultVisualOfScreen
and DefaultColormapOfScreen.  When any one of the three resources is
not properly set, a BadMatch error occurs when the window is
created.  They are not properly set because each of the values depends
on the visual being used.  

How to get this to work?  There are two parts to the answer.  The
first is if you want an application to start with a particular visual
and the second is if you want a particular shell within an application
to start with a different visual.  The second is actually easier
because the basic information you need is available.  The first is a
little harder because you'll need to initialize much of the toolkit
yourself in order to determine the needed information.

/*
 * Some sample code to start up an application using something other
 * than the default visual.
 *
 * To compile:
 *	cc -g visual.c -o visual -lXaw -lXmu -lXt -lXext -lX11 -lm
 *
 * To run:
 *	./visual -geometry 300x300 -depth 24 -visual StaticColor -fg blue -bg yellow
 *
 * you need to move the mouse to get the particular visuals colormap
 * to install.
 */

#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>

typedef struct
{
	Visual	*visual;
	int	depth;
} OptionsRec;

OptionsRec	Options;

XtResource resources[] =
{
	{"visual", "Visual", XtRVisual, sizeof (Visual *),
	XtOffsetOf (OptionsRec, visual), XtRImmediate, NULL},
	{"depth", "Depth", XtRInt, sizeof (int),
	XtOffsetOf (OptionsRec, depth), XtRImmediate, NULL},
};

XrmOptionDescRec Desc[] =
{
	{"-visual", "*visual", XrmoptionSepArg, NULL},
	{"-depth", "*depth", XrmoptionSepArg, NULL}
};



int
main (argc, argv)
	int		argc;
	char		**argv;
{
	XtAppContext	app;		/* the application context */
	Widget		top;		/* toplevel widget */
	Display		*dpy;		/* display */
	char		**xargv;	/* saved argument vector */
	int		xargc;		/* saved argument count */
	Colormap	colormap;	/* created colormap */
	XVisualInfo	vinfo;		/* template for find visual */
	XVisualInfo	*vinfo_list;	/* returned list of visuals */
	int		count;		/* number of matchs (only 1?) */
	Arg		args[10];
	Cardinal	cnt;
	char		*name = "test";
	char		*class = "Test";

	/*
	 * save the command line arguments
	 */

	xargc = argc;
	xargv = (char **) XtMalloc (argc * sizeof (char *));
	bcopy ((char *) argv, (char *) xargv, argc * sizeof (char *));

	/*
	 * The following creates a _dummy_ toplevel widget so we can
	 * retrieve the appropriate visual resource.
	 */
	cnt = 0;
	top = XtAppInitialize (&app, class, Desc, XtNumber (Desc), &argc, argv,
			       (String *) NULL, args, cnt);
	dpy = XtDisplay (top);
	cnt = 0;
	XtGetApplicationResources (top, &Options, resources,
				   XtNumber (resources),
				   args, cnt);
	cnt = 0;
	if (Options.visual && Options.visual != DefaultVisualOfScreen (XtScreen (top)))
	{
		XtSetArg (args[cnt], XtNvisual, Options.visual); ++cnt;
		/*
		 * Now we create an appropriate colormap.  We could
		 * use a default colormap based on the class of the
		 * visual; we could examine some property on the
		 * rootwindow to find the right colormap; we could
		 * do all sorts of things...
		 */
		colormap = XCreateColormap (dpy,
					    RootWindowOfScreen (XtScreen (top)),
					    Options.visual,
					    AllocNone);
		XtSetArg (args[cnt], XtNcolormap, colormap); ++cnt;

		/*
		 * Now find some information about the visual.
		 */
		vinfo.visualid = XVisualIDFromVisual (Options.visual);
		vinfo_list = XGetVisualInfo (dpy, VisualIDMask, &vinfo, &count);
		if (vinfo_list && count > 0)
		{
			XtSetArg (args[cnt], XtNdepth, vinfo_list[0].depth);
			++cnt;
			XFree ((XPointer) vinfo_list);
		}
	}
	XtDestroyWidget (top);


	/*
	 * Now create the real toplevel widget.
	 */
	XtSetArg (args[cnt], XtNargv, xargv); ++cnt;
	XtSetArg (args[cnt], XtNargc, xargc); ++cnt;
	top = XtAppCreateShell ((char *) NULL, class,
				applicationShellWidgetClass,
				dpy, args, cnt);

	/*
	 * Display the application and loop handling all events.
	 */
	XtRealizeWidget (top);
	XtAppMainLoop (app);
	return (0);
}

----------------------------------------------------------------------
5.  Which visual should an application use?
----------------------------------------------------------------------

This is a point that can be argued about but one opinion is there is
no way for an application to know the appropriate visual -- it has to
be specified by the user.  If you disagree with this then your
application probably falls into the category of always using the
default visual or it is hardware specific and expects some particular
visual such as 24bit TrueColor with an OverlayPlane extension (or some
such).

Why?  No application runs in isolation.  Depending on the way a server
allocates resources I may not always want your application to run in
TrueColor mode if it is going to mess up my other applications.  I may
be very upset if it chooses to run in GreyScale instead of PsuedoColor
or just monochrome.

As an example, on a low end color Sun server there are many different
possible visuals: monochrome, 256 entry colormap, static gray, static
color, and a 3/3/2 TrueColor.  The SGI Iris's offer all the above 
plus 12 bit TrueColor, 24 bit TrueColor, an Overlay Plane.

----------------------------------------------------------------------
6.  Why do only Shell widgets have a Visual?
----------------------------------------------------------------------

This is strictly by convention.  It makes it possible for an arbitrary
widget to know that the visual it uses can be found by looking for the
shell widget that is its ancestor and obtaining the visual of that
shell.

A widget can have its own visual resource.  If it does, it must have
its own realize method to use the visual when it calls
XCreateWindow().  You should also make this a resource that can be
obtained with XtGetValues() so other widgets can find it.  A
reasonable value is probably XtNvisual.

----------------------------------------------------------------------
7.  Which visual, depth and colormap do Shells inherit?
----------------------------------------------------------------------

The default value for these resources are set to CopyFromParent.  This
is interpreted as the DefaultColormapOfScreen(), DefaultDepthOfScreen()
and the default visual of the screen if the widget has no parent -- i.e.
it is an applicationShellWidgetClass and the root of your widget tree.

If the parent of the widget is not null, then the shell copies
colormap and depth from its parent and uses CopyFromParent as the
visual.

----------------------------------------------------------------------
8.  I've done all the above and I still get a BadMatch error.  Why?
----------------------------------------------------------------------

Some resource converters improperly cache references.  This was
especially true of X11R3 and earlier versions of Motif.

----------------------------------------------------------------------
9.  Why doesn't my widget get destroyed when I call XtDestroyWidget()?
----------------------------------------------------------------------

See section 2.8 of the Xt specification.

It eventually does get destroyed, just not immediately.  The
Intrinsics destroy a widget in a two-phase process.  First it and all
of its children have a flag set that indicate it is being destroyed.
It is then put on a list of widgets to be destroyed.  This way any
pending X events or further references to that widget can be cleaned
up before the memory is actually freed.  The second phase is then
performed after all callbacks, event handlers, and actions have
completed, before checking for the next X event.  At this point the
list is traversed and each widget's memory is actually free()'d, among
other things.

As some further caveats/trivia, the widgets may be destroyed if the
Intrinsics determine that they have no further references to the
widgets on the list.  If so, then the phase 2 destruction occurs
immediately.  Also, if nested event loops are used, widgets placed on
the destroy list before entering the inner event loop are not
destroyed until returning to the outer event loop.

----------------------------------------------------------------------
10. How do I exit but still execute the DestroyCallbacks?
----------------------------------------------------------------------

The problem is if a simple and entirely reasonable approach to exiting
an application is used, such as calling exit() directly, then a widget
may not have a chance to clean up any external state -- such as open
sockets, temporary files, allocated X resources, etc.  (this code for
simplicity reasons assumes only a single toplevel widget):


	Widget
	ToplevelGet (gw)
		Widget		gw;		/* widget to find toplevel */
	{
		Widget		top;

		for (top = gw; XtParent (top); top = XtParent (top))
			/* empty */;
		return (top);
	}

	void
	ExitCallback (gw, closure, call_data)
		Widget		gw;		/* widget */
		XtPointer	closure;	/* data the app specified */
		XtPointer	call_data;	/* widget specific data */
	{
		Widget		toplevel;

		toplevel = ToplevelGet (gw);
		XtUnmapWidget (toplevel);	/* make it disappear quickly */
		XtDestroyWidget (toplevel);
		exit (0);
	}

One can see that the above code exit's immediately after destroying
the toplevel widget.  The trouble is the phase 2 destruction may never
occur.  

This works for most widgets and most applications but will not work
for those widgets that have any external state.  You might think that
since it works now it will always work but remember that part of the
reason an object oriented approach is used is so one can be ignorant
of the implementation details for each widget.  Which means that the
widget may change and someday require that some external state is
cleaned up by the Destroy callbacks.

One alternative is to modify ExitCallback() to set a global flag and
then test for that flag in a private event loop.  However, private
event loops are frowned upon because it tends to encourage sloppy, and
difficult to maintain practices.

Try the following code instead.

	#include <X11/Intrinsic.h>

	extern Widget ToplevelGet (
	#if NeedFunctionPrototypes
		Widget		gw
	#endif
	);

	extern Boolean ExitWorkProc (
	#if NeedFunctionPrototypes
		XtPointer	closure
	#endif
	);

	extern void ExitCallback (
	#if NeedFunctionPrototypes
		Widget		gw,
		XtPointer	closure,
		XtPointer	call_data
	#endif
	);

	Widget
	ToplevelGet (gw)
	Widget		gw;		/* widget to find toplevel */
	{
		Widget		top;

		for (top = gw; XtParent (top); top = XtParent (top))
			/* empty */;
		return (top);
	}


	void
	ExitCallback (gw, closure, call_data)
	Widget		gw;		/* widget */
	XtPointer	closure;	/* data the app specified */
	XtPointer	call_data;	/* widget specific data */
	{
		Widget		toplevel;

		toplevel = ToplevelGet (gw);
		XtUnmapWidget (toplevel);	/* make it disappear quickly */
		XtDestroyWidget (toplevel);
		XtAppAddWorkProc (XtWidgetToApplicationContext (gw),
				  ExitWorkProc, (XtPointer) NULL);
	}

	Boolean
	ExitWorkProc (closure)
		XtPointer	closure;
	{
		exit (0);
		/*NOTREACHED*/
	}


ExitCallback() adds a work procedure that will get called when the
application is next idle -- which happens after all the events are
processed and the destroy callbacks are executed.

----------------------------------------------------------------------
11. How do I resize a Shell widget?
----------------------------------------------------------------------

After it is realized, one doesn't resize a Shell widget.  The proper
thing is to resize the currently managed child of the Shell widget
using XtSetValues().  The geometry change is then propagated to the
Shell which asks the window manager which may or may not allow the
request.  However, the Shell must have the resource
XtNallowShellResize set to True otherwise it will not even ask the
window manager to grant the request and the Shell will not resize.

To change the position of a Shell, use XtSetValues() on the Shell, not
the child, and within the limits of the window manager it should be granted.

----------------------------------------------------------------------
12. Why can't XtAppAddInput() handle files?
----------------------------------------------------------------------

It does, however Unix semantics for when I/O is ready for a file does
not fit most peoples' intuitive model.  In Unix terms a file
descriptor is ready for reading whenever the read() call would not
block, ignoring the setting of optional flags that indicate not to
block.  This works as expected for terminals, sockets and pipes.  For
a file the read() will always return but the return indicates an EOF
-- i.e. no more data.  The result is the code in the Intrinsics always
calls the input handler because it always thinks something is about to
be read.  The culprit is the select() system call or on SYSV based
OS's it is the poll() system call.

How to get around this on a Unix system?  The best approach is to use
another process to check for available input on the file.  Use a pipe
to connect the application with this other process and pass the file
descriptor from the pipe to XtAppAddInput().  A suitable program on
BSD systems is "tail -f filename".

It's rumored that select() on some systems is not _completely_
reliable.  In particular:

	- IBM AIX 3.1: this is one where it would work for a while
	  (several thousand times) and then stop until some other
	  event woke it up. This seemed to be the result of a race
	  condition in the Kernel.  IBM claims to have a fix for this.

	- Pyramid, doesn't work at all.

	- Ultrix (and possibly others where pipes are implemented as
	  sockets), wasn't completely broken, but although the writing
	  side wrote in 512 byte blocks the reading side received it
	  all broken up as if it was being put into the pipe a byte at
	  a time.  You can waste a lot of time by reading small blocks
	  (get raound it by detecting the situation and having
	  select() ignore the pipe for 10 mseconds - by then it had
	  been given the whole block).


Note that all the above descriptions used Unix terminology such as
read(), file descriptor, pipes, etc.  This is an OS dependent area and
may not be identical on all systems.  However the Intrinsic designers
felt it was a common enough operation that it should be included with
part of the toolkit.  Why they didn't also deal with signals at this
point I don't know.

----------------------------------------------------------------------
13. What good books and magazines are there on Xt?
----------------------------------------------------------------------

I have a favorite that is the definitive reference.  To my perspective
it offers a reasonable introduction but also goes into the full
details of the Intrinsics.  When I started using it I was already
familiar with Xt and the concepts behind it, so newcomers may or may
not find it useful.  I've always found it accurate and complete, which
means its a 1000 pages.

Asente, Paul J., and Swick, Ralph R., "X Window System Toolkit, The
	Complete Programmer's Guide and Specification", Digital Press,
	1990, ISBN 1-55558-051-3, order number EY-E757E-DP; and by
	Prentice-Hall, ISBN 0-13-972191-6. Also available through DEC
	Direct at 1-800-DIGITAL.

The other book I commonly recomend to novices is:

Young, Doug. "The X Window System: Applications and Programming with
	Xt (Motif Version)," Prentice Hall, 1989 (ISBN 0-13-497074-8).
	(ISBN 0-13-972167-3)

And of course O'Reilly has an entire series of manuals on X and Xt.
O'Reilly ordering is 800-998-9938.  In particular, Volume 5 is an Xt
reference done in manual page style.  The 3rd edition is extensively
overhauled and goes far beyond the MIT manual pages.  I'm finding it
very useful.  In particular, the permutted index and references to
other manual pages help a great deal in chasing down related
information.

I read two periodicals, "The X Resource" and the "The X Journal".
These are the only two dealing specifically with X.  "The X Resource"
is published quarterly, by O'Reilly, with one of the issues being the
MIT X Consortium Technical Conference Proceedings.  There is no
advertising.  I've found it informative with pretty good depth.  For
orders, call 1-800-998-9938, or email cathyr@ora.com.  For editorial
matters, email adrian@ora.com.  Table of contents are posted at
math.utah.edu in ~ftp/pub/tex/bib in TeX form and on ftp.uu.net in
~ftp/published/oreilly/xresource in ASCII form.


"The X Journal" is a bimonthly trade rag with lots of advertising.
The articles are informative and oriented toward a less technical
audience.  I read it more to see what's going on then with an
expectation of learning a great deal (but remember, I represent a
fairly small percentage of people).  Also, they have a pretty good
collection of people on the advisory board and as columnists.  Call
(908) 563-9033.

----------------------------------------------------------------------
14. What Widgets are available?
----------------------------------------------------------------------

There are three popular widget sets:

Athena	- The set provided with X11.  This is sufficient for most
	  purposes but is on the ugly side.  Recently, a 3d look is
	  available for ftp on export.lcs.mit.edu:/contrib/Xaw3d.tar.Z.
Motif	- From OSF available for a license fee and commonly shipped on
	  many workstation vendors platforms (almost everyone but
	  Sun).  It looks good and works well but personally I think
	  it is poorly implemented.
OLIT	- The Open Look Intrinsics Toolkit is a set of widgets
	  implementing Sun's Open Look specification.  Developed by
	  AT&T.  I've never used it so can't comment on its quality.
	  I've heard rumours that it is a pain to actually get.

In addition the following collection of widgets are also available:

Xtra	- a library of widgets for sale from Graphical Software
	  Technology (310-328-9338).  It includes bar graph, stacked
	  bar graph, line graph, pie chart, xy plot, hypertext, help,
	  spreadsheet, and data entry form widgets.  I've never seen
	  them so I can't comment.
FWF	- The Free Widget Foundation is attempting to collect a set of
	  freely available widgets.  Included are a Pixmap editor,
	  FileDialog, and a few others.  The current set of widgets
	  can be obtained via anonymous ftp from the machine
	  a.cs.uiuc.edu (128.174.252.1) in the file pub/fwf.shar.Z.
Xcu	- The Cornell University widgets from Gene Dykes.  One of the
	  early widget sets released.  Provides a nice appearance for
	  buttons and has a mini command language.  Probably not so
	  widely used.
Xs	- The Sony widget set.  This was around during R3 days but
	  seemed to disappear.  It looked like it had promise.
Xw	- The HP widgets.  The precursor to Motif.  Originally written
	  for R3 there exists diffs to get it to work under R4 & R5.
	  Again, a pretty good widget set but has more or less died.
	  The precursor to this was the Xray toolkit which was
	  originally implemented for X10R4 and apparently provided
	  much experience for the designers of Xt.
Xo	- A widget set I'm working on.  It's still primitive but you
	  can give it a try in archive.cis.ohio-state.edu:pub/Xo/*

The following specialized widgets are also available:

Tbl	- Implements a tabular layout of widgets.  Supports Motif
	  widgets as children.  Part of Wcl.
Plots	- The Athena Plotting widgets (not the Athena widgets).
	  Contact gnb@bby.oz.au or joe@Athena.MIT.EDU.

----------------------------------------------------------------------
15. What alternatives to the Intrinsics are there?
----------------------------------------------------------------------

	__________________________________________
	Name		Language	Vendor
	__________________________________________
	Xview		C		Sun
	OI		C++		ParcPlace
	Interviews	C++		Stanford
	Tcl/tk		C		sprite.berkeley.edu
	__________________________________________


However much I like C and admire the skill in both designing and
implementing the Intrinsics, hopefully some alternative will develop
in the next 3-5 years that uses an object oriented language.  Keep
your eyes open and expect some change about the same time a language
other than C _starts_ gaining acceptance.

----------------------------------------------------------------------
16. How do I pass a float value to XtSetValues?
----------------------------------------------------------------------

First, what is going wrong is the structure for an Arg is (essentially)
	typdef struct
	{	
	    String	name;
	    long	value;
	} Arg;

and the code:
	Arg	arg;

	XtSetArg (arg, "name", 3.2)

expands to
	Arg	arg;

	arg.name = "name";
	arg.value = 3.2;

you can see that with normal C type conversions, the arg.value
gets the integer "3" instead of the floating point value "3.2".  When
the value is copied into the widget resource, the bit pattern is
wildly different than that required for a floating point value.  So,
how to get around this?

The following macro is from the Athena widgets document and I am now
recomending it over the previous suggestions.

#define XtSetFloatArg(arg, n, d) \
    if (sizeof(float) > sizeof(XtArgVal)) { \
        XtSetArg(arg, n, &(d)); \
    } else { \
        XtArgVal *ld = (XtArgVal *)&(d); \
        XtSetArg(arg, n, *ld); \
    }


----------------------------------------------------------------------
17. How do I write a resource converter?
----------------------------------------------------------------------

Courtesy of Rich Thomson (rthomson@dsd.es.com):

The following discussion of resource converters assumes R4 (or R5)
Intrinsics.  Resource converters changed between R3 and R4 to allow
for destructors and caching of converted values.

There are several main types of resource converters:

    string to data type
    data type to string
    data type to data type

i) string to data type
    Usually a string to data type converter has a fixed set of strings
    that will be converted to data type values.  This is most often
    used to map enumerated names to enumerated values:

	Name		Value
	"True"		1
	"False"		0

    In this case, the string to data type converter needs to compare
    the resource value to the list of fixed strings.  This is most
    readily accomplished by the use of the "quark" mechanism of the
    resource manager.  The resource value is turned into a quark,
    which is a unique representation of the string that fits into a
    single word.  Then the resource quark is compared against the
    quarks for the fixed strings representing the enumerated values.

    If there are many enumerated strings in the converter (or many
    converters, each with a small number of enumeration strings), then
    a global initialization routine might be used to turn all the
    resource strings into quarks.  That way, the first time one of
    these converters is used, the strings will be turned into quarks
    and held in static variables for use in the next invocation of one
    of the converters.

ii) data type to string
    This type of converter is slightly easier than the string to data
    type converters since the use of quarks isn't necessary.  Instead,
    the data type value is simply converted to a string value,
    probably by the use of sprintf.

    Data type to string converters are useful for applications that
    wish to convert an internal data type value into a string so that
    they can write out a valid resource specification to a file.  This
    mechanism can be used to provide a "snapshot" of application state
    into a file.  This snapshot can be used to restore the program to
    a known state via the usual X resource database mechanisms.

    If you are taking the trouble to write a string to data type
    converter, it isn't much extra effort to write the data type to
    string converter.  Writing both at the same time helps to ensure
    that they are consistent.

iii) data type to data type
    This type of converter is used to convert an existing data type
    value to another data type.  For instance, an X pixel value can be
    converted to an RGB data type that contains separate fields for
    red, green and blue.


The type signature for a resource converter is as follows:

typedef Boolean (*XtTypeConverter)(Display *, XrmValuePtr, Cardinal *,
	XrmValuePtr, XrmValuePtr, XtPointer *);
    Display *dpy;
    XrmValuePtr args;
    Cardinal *num_args;
    XrmValuePtr fromVal;
    XrmValuePtr toVal;
    XtPointer *converter_data;

When the converter is invoked, the "fromVal" argument points to the source
X resource manager value and the "toVal" argument points to the
destination X resource manager value.  The "converter_data" argument
is an opaque pointer to some converter-specific data that is specified
when the converter is registered.  The "args" and "num_args" arguments
allow extra information to be passed to the converter when it is
invoked.  For instance, the Pixel to RGB structure converter discussed
above would need colormap and visual arguments in which to lookup the
Pixel to obtain the RGB values corresponding to that pixel.

Care must be taken with the "toVal" argument.  An XrmValue has the
following type definition and specifies a size and location for a
converted value:

typedef struct {
    unsigned int    size;
    caddr_t         addr;
} XrmValue, *XrmValuePtr;

When the converter is invoked, the address may point to a location of
the given size for the converted value or the location can be NULL.
In the former case, the converter should ensure that the size of the
destination area is large enough to handle the converted value.  If
the destination area is not large enough, then the converter should
set the size to the amount of space needed and return False.  The
caller can then ensure that enough space is allocated and reinvoke the
converter.  If the size is large enough, then the converter can simply
copy the converted value into the space given and return True.

If the location is NULL, then the converter can assign the location to
the address of a static variable containing the converted value and
return True.

When writing a group of converters, this code is often repeated and it
becomes convenient to define a macro:

    #define DONE(var, type) \
      if (toVal->addr) \
	{ \
	  if (toVal->size < sizeof(type)) \
	    { \
	      toVal->size = sizeof(type); \
	      return False; \
	    } \
	  else \
	    *((type *) toVal->addr) = var; \
	} \
      else \
	toVal->addr = (caddr_t) &var; \
      toVal->size = sizeof(type); \
      return True;

    #define DONESTR(str) \
      if (toVal->addr && toVal->size < sizeof(String)) \
	{ \
	  toVal->size = sizeof(String); \
	  return False; \
	} \
      else \
	toVal->addr = (caddr_t) str; \
      toVal->size = sizeof(String); \
      return True;

Inside the converter, it is a good idea to perform a little safety
checking on the "num_args" and "args" arguments to ensure that your
converter is being called properly.

Once you have written your converter, you need to register it with the
Intrinsics.  The Intrinsics invokes resource converters when creating
widgets and fetching their resource values from the resource database.

To register a converter with a single application context, use
XtAppSetTypeConverter:

void XtAppSetTypeConverter(context, from, to, converter, args, num_args,
	cache, destructor)
    XtAppContext context;
    String from;
    String to;
    XtTypeConverter converter;
    XtConvertArgList args;
    Cardinal num_args;
    XtCacheType cache;
    XtDestructor destructor;

To register a converter with all application contexts, use
XtSetTypeConverter:

void XtSetTypeConverter(from, to, converter, args, num_args,
	cache, destructor)
    String from;
    String to;
    XtTypeConverter converter;
    XtConvertArgList args;
    Cardinal num_args;
    XtCacheType cache;
    XtDestructor destructor;

In the R3 Intrinsics, there were the routines XtAppAddConverter and
XtAddConverter; these have been superseded by XtAppSetTypeConverter
and XtSetTypeConverter.  Whenever possible, the newer routines should be
used.

When a converter is registered with the Intrinsics, a "cache" argument
specifies how converted resource values are to be cached:

    XtCacheNone		Don't cache any converted values
    XtCacheAll		Cache all converted values
    XtCacheByDisplay	Cache converted values on a per display basis

Caching converted values that require a round-trip to the server is a
good idea (for instance string to Pixel conversions).

The "destructor" argument is a routine that is invoked then the
resource is destroyed, either because its cached reference count has
been decremented to zero or because the widget owning the value is
being destroyed.  XtDestructor has the following type definition:

typedef void (*XtDestructor)(XtAppContext, XrmValuePtr, XtPointer,
	XrmValuePtr, Cardinal *);
    XtAppContext context;
    XrmValuePtr to;
    XtPointer converter_data;
    XrmValuePtr args;
    Cardinal *num_args;

The destructor is invoked to free any auxiliary storage associated
with the "to" argument, but does not actually free the storage pointed
to by the "to" argument itself (to->addr).  The destructor is passed
the extra arguments that were passed to the converter when the
conversion was performed (for instance, colormap and visual arguments
for the string to Pixel converter since the destructor would need to
free the allocated Pixel from the colormap) as well as the private
data passed in when the converter was registered.

Sample converter code can be found in the following files in the MIT
R5 distribution:

    mit/lib/Xt/Converters.c
    contrib/lib/PEXt/Converters.c
    contrib/lib/PEXt/Converters.h

----------------------------------------------------------------------
18. How do I open multiple displays?
----------------------------------------------------------------------

See "Multi-user Application Software Using Xt", The X Resource, Issue 3,
(Summer 1992) by Oliver Jones for a complete coverage of the issues
involved.  Most of this answer is based on that article.  In a
nutshell, one uses XtOpenDisplay() to add each display to a _single_
application context and then XtCloseDisplay() to shutdown each display
and remove it from the application context.

The real problems occur when trying to close down a display.  This can
happen 3 ways:
	1. User selects a "quit" button on one of the displays,
	2. User has window manager send a WM_DELETE_WINDOW message,
	3. Server disconnect -- possibly from a KillClient message,
	   server shutdown/crash, or network failure.

I'll assume you can deal gracefully with 1 & 2 since it is _merely_ a
problem of translating a Widget to a display and removing that
display.  If not, then read the Oliver Jones article.

The third one is difficult to handle.  The following is based on the
Oliver Jones article and I include it here because it is a difficult
problem.

The difficulty arises because the Xlib design presumed that an I/O
error is always unrecoverable and so fatal.  This is essentially true
for a single display X based application, but not true for a
multiple display program or an application that does things other than
display information on an X server.  When an X I/O error occurs the
I/O error handler is called and _if_ it returns then an exit()
happens.  The only way around this is to use setjmp/longjmp to avoid
returning to the I/O error handler.  The following code fragment
demonstrates this:

#include <setjmp.h>
jmp_buf XIOrecover;

void
XIOHandler (dpy)
	Display		*dpy;
{
	destroyDisplay (dpy);
	longjmp (XIOrecover, 1);
}

main ()
{
	...
	if (setjmp (XIOrecover) == 0)
		XSetIOErrorHandler (XIOHandler);
	XtAppMainLoop (app_context);
}

The destroyDisplay() is something that given a Display pointer can go
back to the application specific data and perform any necessary
cleanup.  It should also call XtCloseDisplay().

For those of you unfamiliar with setjmp/longjmp, when setjmp() is
first called it returns a 0 and save's enough information in the
jmp_buf that a latter execution of longjmp() can return the program to
the same state as if the setjmp() was just executed.  The return value
of this second setjmp() is the value of the second argument to
longjmp().  There are several caveats about using these but for this
purpose it is adequate.

Some other problems you might run into are resource converters that
improperly cache resources.  The most likely symptoms are Xlib errors
such as BadColor, BadAtom, or BadFont.  There may be problems with the
total number of displays you can open since typically only a limited
number of file descriptors are available with 32 being a typical
value.  You may also run into authorization problems when trying to
connect to a display.

There was much discussion in comp.windows.x about this topic in
November of 91.  Robert Scheifler posted an article which basically
said this is the way it will be and Xlib will not change.

----------------------------------------------------------------------
19. What changed from R3 to R4 to R5?
----------------------------------------------------------------------

This addresses only changes in the Intrinsics.  First, the general
changes for each release are described.  Then a, certainly incomplete,
list of new functions added and others that are now deprecated are
listed.  Brevity is a primary goal.

Much of the following information is retrieved from Chapter 13 of the MIT
Xt Intrinsics Manual and from O'Reilly Volume 5, 3rd edition.

From R3 to R4
- Addition of gadgets (windowless widgets)
- New resource type converter interface to handle cacheing and
  additional  data.
- Variable argument list interface.
- #define XtSpecificationRelease 4  (added with this release)
- WMShellPart, TopLevelShellPart & TransientShellPart changed
  incompatibly.
- core.initialize, core.set_values added ArgList and count parameters
- event handlers had continue_to_dispatch parameter added
- core.set_values_almost specification changed.
- core.compress_exposure changed to an enumerated data type from Boolean
- core.class_inited changed to enumerated data type from Boolean
- constraint.get_values_hook added to extension record
- core.initialize_hook obsolete as info is passed to core.initialize
- shell.root_geometry_manager added to extension record
- core.set_values_hook obsolete as info is passed to core.set_values
- Calling XtQueryGeometry() must store complete geometry.
- Added UnrealizeCallback.
- XtTranslateCoords() actually works under R4.

From R4 to R5:
- Psuedo resource baseTranslation added.
- Searching for app-default, and other files, made more flexible
- customization resource added.
- Per-screen resource database.
- Support permanently allocated strings.
- Permanetly allocated strings required for several class fields.
- The args argument to XtAppInitialize, XtVaAppInitialize,
  XtOpenDisplay, XtDisplayInitialize, and XtInitialize were changed
  from Cardinal* to int*
- Many performance improvements (this is summarized from the article
  "Xt Performance Improvements in Release 5" by Gabe Beged-Dov in "The
  X Resource", Issue 3):
	- XrmStringToQuark() augmented with XrmPermStringToQuark() to
	  avoid string copies.  Several fields in the class record are
	  indicated as needing permanent strings.
	- Using an array of Strings for resources
	- Callback lists redesigned to use less memory
	- Translation manager redesigned and rewritten so it takes
	  less memory, translation tables merges are faster, cache of
	  action bindings
	- Keycode to Keysyms are cached.
	- Better sharing of GC's with modifiable fields
	- Window to Widget translation uses less space and faster
	- Does not malloc space for widget name since quark is available
	- Widget space is allocated to include the constraints
	- Over several example programs, about a 26% reduction in
	  memory usage.

Functions new with R5:
----------------------
XtAllocateGC()		- sharable GC with modifiable fields  
XtGetActionList()	- get the action table of a class
XtScreenDatabase()	- return resource database for a screen
XtSetLanguageProc()	- register language procedure called to set locale


Functions new with R4:
----------------------
XtAppAddActionHook()	- procedure to call before _every_ action.
XtAppInitialize()	- lots of initialization work.
XtAppReleaseCacheRefs()	- decrement cache reference count for converter
XtAppSetFallbackResources() - specify default resources
XtAppSetTypeConverter()	- register a new style converter
XtCallCallbackList()	- directly execute a callback list
XtCallConverter	()	- invoke a new style converter
XtCallbackReleaseCacheRef() - release a cached resource value
XtCallbackReleaseCacheRefList() - release a list of cached resource values
XtConvertAndStore()	- find and call a resource converter
XtDirectConvert()	- Invoke old-style converter
XtDisplayOfObject()	- Return the display
XtDisplayStringConversionWarning() - issue a warning about conversion
XtFindFile()		- Find a file
XtGetActionKeysym()	- Retrieve keysym & modifies for this action
XtGetApplicationNameAndClass() - return name and class
XtGetConstraintResourceList() - get constraints for a widget
XtGetKeysymTable()	- return keycode-to-keysym mapping table
XtGetMultiClickTime()	- read the multi-click time
XtGetSelectionRequest()	- retrieve the SelectionRequest event
XtGetSelectionValueIncremental() - obtain the selection value incrementally
XtGetSelectionValuesIncremental() - obtain the selection value incrementally
XtInitializeWidgetClass() - initialize a widget class manually
XtInsertEventHanlder()	- register event handler before/after others
XtInsertRawEventHandler() - register event handler without modify input mask
XtIsObject()		- test if subclass of Object
XtIsRectObj()		- test if subclass of RectObj
XtKeysymToKeyCodeList()	- return list of keycodes
XtLastTimestampProcessed() - retrieve most recent event time
XtMenuPopdown		- Action for popping down a widget
XtMenuPopup		- Action for popping up a widget
XtOffsetOf		- macro for structure offsets
XtOwnSelectionIncremental() - make selection data availabe incrementally
XtPoupSpringLoaded()	- map a spring-loaded popup
XtRegisterGrabAction()	- indicate action procedure needs a passive grab
XtRemoveActiohHook()	- remove function called after every action
XtResolvePathname()	- find a file
XtScreenOfObject()	- return screen of object.
XtSetMultiClickTime()	- set the multi-click time
XtSetWMColormapWindows() - set WM_COLORMAP_WINDOWS for custom colormaps
XtUngrabButton()	- cancel a passive button grab
XtUngrabKey()		- cancel a passive key grab
XtUngrabKeybard()	- release an active keyboard grab
XtUngrabPointer()	- release an active pointer grab
XtVa*()			- varags interfaces to a bunch of functions
XtWindowOfObject()	- return Window of nearest widget ancestor


Deprecated		Replacement			When
----------------------------------------------------------------------
XtAddActions()		XtAppAddActions()		R3
XtAddConverter()	XtAppAddConverter()		R3
XtAddInput()		XtAppAddInput ()		R3
XtAddTimeout()		XtAppAddTimeout()		R3
XtAddWorkProc()		XtAppAddWorkProc()		R3
XtConvert()		XtConvertAndStore()		R4
XtCreateApplicationShell XtAppCreateShell()		R3
XtDestroyGC()		XtReleaseGC()			R3
XtError()		XtAppError()			R3
XtGetErrorDatabase()	XtAppGetErrorDatabase		R3
XtGetErrorDatabaseText() XtAppGetErrorDatabaseText	R3
XtGetSelectionTimeout()	XtAppGetSelectionTimeout	R3
XtInitialize()		XtAppInitialize()		R3
XtMainLoop()		XtAppMainLoop()			R3
MenuPopdown(action)	XtMenuPopdown(action)		R4
MenuPopup(action)	XtMenuPopup(action)		R4
XtNextEvent()		XtAppNextEvent()		R3
XtPeekEvent()		XtAppPeekEvent()		R3
XtPending()		XtAppPending()			R3
XtSetErrorHandler()	XtAppSetErrorHandler()		R3
XtSetErrorMsgHandler	XtAppSetErrorMsgHandler()	R3
XtSetSelectionTimeout()	XtAppSetSelectionTimeout()	R3
XtSetWarningHandler()	XtAppSetWarningHandler()	R3
XtSetWarningMsgHandler() XtAppSetWarningMsgHandler()	R3
XtWarning()		XtAppWarning()			R3
XtWarningMsg()		XtAppWarningMsg()		R3

----------------------------------------------------------------------
20. Where are the resources loaded from?
----------------------------------------------------------------------

The resources of a widget are filled in from the following places
(from highest priority to lowest priority):

	1. Args passed at creation time.
	2. Command line arguments.
	3. User's per host defaults file
	4. User's defaults file.
	5. User's per application default file.
	6. System wide per application default file.

Note that 2-6 are read only once on application startup.  The result
of steps 3-6 is a single resource database used for further queries.

The per host defaults file contains customizations for all
applications executing on a specific computer.  This file is either
specified with the XENVIRONMENT environment variable or if that is not
set then the file $HOME/.Xdefaults-<host> is used.

The user defaults file is either obtained from the RESOURCE_MANAGER
property on the root window of the display or if that is not set then
the file $HOME/.Xdefaults is used.  Typically, the program "xrdb" is
used to set the RESOURCE_MANAGER property.  Please note that this
should be kept relatively small as each client that connects to the
display must transfer the property.  A size of around 1-3KByte is
reasonable.  Some toolkits may track changes to the RESOURCE_MANAGER
but most do not.

A user may have many per application default files containing
customizations specific to each application.  The intrinsics are quite
flexible on how this file is found.  Read the next part that describes
the various environment variables and how they effect where this file
is found.

The system wide per application default files are typically found in
/usr/lib/X11/app-defaults.  If such a file is not found then the
fallback resources are used.  The intrinsics are quite flexible on how
this file is found.  Read the next part that describes the various
environment variables and how they effect where this file is found.

[Thanks to Oliver Jones (oj@pictel.com) for the following, 6/92]

You can use several environment variables to control how resources are
loaded for your Xt-based programs -- XFILESEARCHPATH,
XUSERFILESEARCHPATH, and XAPPLRESDIR.  These environment variables
control where Xt looks for application-defaults files as an
application is initializing.  Xt loads at most one app-defaults file
from the path defined in XFILESEARCHPATH and another from the path
defined in XUSERFILESEARCHPATH.

Set XFILESEARCHPATH if software is installed on your system in such a
way that app-defaults files appear in several different directory
hierarchies.  Suppose, for example, that you are running Sun's Open
Windows, and you also have some R4 X applications installed in
/usr/lib/X11/app-defaults. You could set a value like this for
XFILESEARCHPATH, and it would cause Xt to look up app-defaults files
in both /usr/lib/X11 and /usr/openwin/lib (or wherever your
OPENWINHOME is located):

	setenv XFILESEARCHPATH /usr/lib/X11/%T/%N:$OPENWINHOME/lib/%T/%N

The value of this environment variable is a colon-separated list of
pathnames.  The pathnames contain replacement characters as follows
(see XtResolvePathname()):

	%N	The value of the filename parameter, or the
		application's class name.
	%T	The value of the file "type".  In this case, the
		literal string "app-defaults"
	%C	customization resource (R5 only)
	%S	Suffix.  None for app-defaults.
	%L	Language, locale, and codeset (e.g. "ja_JP.EUC")
	%l	Language part of %L  (e.g. "ja")
	%t	The territory part of the display's language string
	%c	The codeset part of the display's language string

Let's take apart the example.  Suppose the application's class name is
"Myterm". Also, suppose Open Windows is installed in /usr/openwin.
(Notice the example omits locale-specific lookup.)

	/usr/lib/X11/%T/%N        means /usr/lib/X11/app-defaults/Myterm
	$OPENWINHOME/lib/%T/%N    means /usr/openwin/lib/app-defaults/Myterm

As the application initializes, Xt tries to open both of the above
app-defaults files, in the order shown.  As soon as it finds one, it
reads it and uses it, and stops looking for others.  The effect of
this path is to search first in /usr/lib/X11, then in /usr/openwin.

Let's consider another example. This time, let's set
XUSERFILESEARCHPATH so it looks for the file Myterm.ad in the current
working directory, then for Myterm in the directory ~/app-defaults.

	setenv XUSERFILESEARCHPATH ./%N.ad:$HOME/app-defaults/%N

The first path in the list expands to ./Myterm.ad.  The second expands
to $HOME/app-defaults/Myterm.  This is a convenient setting for
debugging because it follows the Imake convention of naming the
app-defaults file Myterm.ad in the application's source directory, so
you can run the application from the directory in which you are
working and still have the resources loaded properly.

NOTE: when looking for app-default files with XUSERFILESEARCHPATH,
      for some  bizarre reason, neither the type nor file suffix is
      defined so %T and %S are useless.

With R5, there's another twist.  You may specify a customization
resource value.  For example, you might run the "myterm" application
like this:

	myterm -xrm "*customization: -color"

If one of your pathname specifications had the value
"/usr/lib/X11/app-defaults/%N%C" then the expanded pathname would be
"/usr/lib/X11/app-defaults/Myterm-color" because the %C substitution
character takes on the value of the customization resource.

The default XFILESEARCHPATH, compiled into Xt, is:

		/usr/lib/X11/%L/%T/%N%C:\  (R5)
		/usr/lib/X11/%l/%T/%N%C:\  (R5)
		/usr/lib/X11/%T/%N%C:\     (R5)
		/usr/lib/X11/%L/%T/%N:\
		/usr/lib/X11/%l/%T/%N:\
		/usr/lib/X11/%T/%N

(Note: some sites replace /usr/lib/X11 with a ProjectRoot in this
batch of default settings.)

The default XUSERFILESEARCHPATH, also compiled into Xt, is 

		<root>/%L/%N%C:\  (R5)
		<root>/%l/%N%C:\  (R5)
		<root>/%N%C:\     (R5)
		<root>/%L/%N:\
		<root>/%l/%N:\
		<root>/%N:

<root> is either the value of XAPPLRESDIR or the user's home directory
if XAPPLRESDIR is not set.  If you set XUSERFILESEARCHPATH to some
value other than the default, Xt ignores XAPPLRESDIR altogether.

Notice that the quick and dirty way of making your application find
your app-defaults file in your current working directory is to set
XAPPLRESDIR to ".", a single dot.  In R3, all this machinery worked
differently; for R3 compatibilty, many people set their XAPPLRESDIR
value to "./", a dot followed by a slash.


----------------------------------------------------------------------
21. What order are callbacks executed in?
----------------------------------------------------------------------
(Courtesy of Donna Converse, converse@expo.lcs.mit.edu; 5/10/92)

The Intrinsics library do not guarantee an order.  This is because
both the widget writer and the application writer have the ability to
modify the entire contents of the callback list.  Neither one
currently knows what the other is doing and so the Intrinsics cannot
guarantee the order of execution.

The application programmer cannot rely on the widget writer; the
widget writer is not required to document when the widget will add and
remove callbacks from the list or what effect this will have;
therefore the functionality contained in a callback should be
independent of the functionality contained in other callbacks on the
list.

Even though the Xt standard in the definition of XtAddCallback
says:

 	"callback_name: Specifies the callback list to which the
 	procedure is to be appended."
 
you may not infer from the word "appended" that the callback routines
are called in the same order as they have been added to the callback
list.

----------------------------------------------------------------------
22. How do I know if a widget is visible?
----------------------------------------------------------------------
(Courtesy of Donna Converse, converse@expo.lcs.mit.edu; 5/14/92)

> I am building a widget needs to know if it is visible. I set the visible
> interest field in Core and if my window is completely obscured, the Core
> visible flag goes FALSE. However, if my window is iconified, the flag
> stays set to TRUE.

Right, everything is implemented correctly.  This demonstrates a "deficiency"
in the X protocol, and the Core widget is reflecting the capabilities of the
protocol.  (The "deficiency" is that the information is available in one way,
in this case an inconvenient way.)  The Xt specification is accurate, in
the second and third paragraphs of section 7.10.2, so read this section
carefully.  The visible field will not change in response to iconification.

A VisibilityNotify event will not be received when the window goes from
viewable to unviewable, that is, when the widget or an ancestor is unmapped;
that is, when iconification occurs.  This is the protocol deficiency.
Visibility state and viewable state have specific meanings in the X protocol;
see the glossary in your Xlib and X protocol reference manual.

> Is this a problem with "mwm" or is there something
> else which needs to be done?

You'll see this with any window manager, with no window manager.

> If the problem is "mwm", what is the fastest
> way to determine if a window is iconified? 

As an application writer, keep track with a global Boolean in an action
routine with translations for MapNotify and UnmapNotify on the Shell widget
which contains your custom widget.  As the custom widget writer, see the
map_state field returned by a call to XGetWindowAttributes.  These are
suggestions.

----------------------------------------------------------------------
23. How do I reparent a widget in Xt, i.e. XtReparentWidget()?
----------------------------------------------------------------------

You can't.

----------------------------------------------------------------------
24. Why use XtMalloc, XtFree, etc?
----------------------------------------------------------------------

Unfortunately, most code that calls malloc(), realloc() or calloc()
tends to ignore the possibility of returning NULL.  At best it is
handled something like:

	ptr = (type *) malloc (sizeof (type))
	if (!ptr)
	{
		perror ("malloc in xyzzy()");
		exit (1)
	}
To handle this common case the Intrinsics define the functions
XtMalloc(), XtCalloc(), XtNew(), XtNewString() and XtRealloc() which
all use the standard C language functions malloc(), calloc() and
realloc() but execute XtErrorMsg() if a NULL value is returned.  Xt
error handlers are not supposed to return so this effectively exits.

In addition, if XtRealloc() is called with a NULL pointer, it uses
XtMalloc() to get the initial space.  This allows code like:

	if (!ptr)
		ptr = (type *) malloc (sizeof (type));
	else
		ptr = (type *) realloc (ptr, sizeof (type) * (count + 1));
	++count;

to be written as:

	ptr = XtRealloc (ptr, sizeof (ptr) * ++count);

Also, XtFree() accepts a NULL pointer as an argument.  Generally, I've
found the Xt functions conveniant to use.  However, anytime I'm
allocating anything potentially large I use the standard functions so
I can fully recover from not enough memory errors.

XtNew() and XtNewString() are conveniant macros for allocating a
structure or copying a string:

	  struct abc *xyzzy;
	  char	     *ptr;
	  char	     *str = "abcdef";

	  xyzzy = XtNew (struct abc);	/* takes care of type casting */
	  ptr = XtNewString (str);

A strict interpretation of the Intrinsics reference manual allow an
implementation to provide functions that are not exchangable with
malloc() and free().  I.e. code such as:

	 char	      *ptr;

	 ptr = XtMalloc (100);
	 /* ... */
	 free (ptr);

may not work.  Personally, I'd call any implementation that did this
broken and complain to the vendor.

A common error for Motif programmers is to use XtFree() on a string
when they should really be using XmStringFree().

----------------------------------------------------------------------
25. How to debug an Xt application?
----------------------------------------------------------------------
First, I'd recomend getting "purify" from Pure Software.  This is a
great package for tracing memory problems on Sun's.  It's a bit pricey
at $2750 but I'd still recomend it.  Excuse the marketing blurb
(contact support@pure.com for more info).

	Purify inserts additional checking instructions directly into
	the object code produced by existing compilers.  These
	instructions check every memory read and write performed by
	the program under test and detect several types of access
	errors, such as reading unitialized memory, writing past
	malloc'd bounds, or writing to freed memory.  Purify inserts
	checking logic into all of the code in a program, including
	third party and vendor object-code libraries, and verifies
	system call interfaces.  In addition, Purify tracks memory
	usage and identifies individual memory leaks using a novel
	adaption of garbage collection techniques.  Purify's nearly
	comprehensive memory access checking slows the target program
	down typically by a factor of two to five.

An alternative package that isn't as pricey ($395 for a Sun), runs on
many Unix's and has pretty similar features is "The SENTINEL Debugging
Environment".  This replaces malloc() and several other C library
functions to add additional checks.  (contact cpcahil@virtech.vti.com
for more info)

Next, if you are getting any sort of Xlib error, you'll need to run in
synchronous mode, easily accomplished with the "-sync" command line
argument or by setting the variable Xdebug to 1 with your debugger.  Then
set a break point in exit().  This will let you trace back to the
original Xlib function being called.  If you don't run in synchronous
mode, then the actual error may have occured any number of calls to
Xlib previously since the Xlib calls are buffered and replies from the
server are asynchronous.

Next, if you are having trouble with window layout, you can use the
undocumented resource "xtIdentifyWindows" or the class resource
"XtDebug" to cause the widget name to be identified with each window.
For example:

    example% xload -xrm '*XtDebug:true' &
    example% xwininfo -tree
	     <click in new xload window>

will give the normal information but the widget name and class of each
window is included.  This can help for checking the location and size
of errant widgets.

Next, if you are having trouble with geometry managers or you want to
test the way a widget manages it's children, you can try
export.lcs.mit.edu:contrib/libXtGeo.tar.Z.  This acts as a filter
between any children and a geometry manager and checks the behaviour
of both.  It's a very clever idea.

The most unfortunate problem is debugging a callback while the
application is executing a grab of the keyboard or mouse (such as from
a pulldown menu).  The server effectively locks up and you'll need to
go to another machine and kill the debugger manually.  The server
locks up because the application being debugged has said no one else
can have access to the keyboard but the application is not stopped
waiting because the debugger is waiting for your commands.
Unfortunately you can't give them because all the input is going to
your application which is stopped.

The best way to debug this kind of problem is with two machines on
your desk, running the program under a debugger (or other environment)
on one machine, and running the application on the other, possibly
using a command sequence like this:

	othermachine% xhost +thismachine
	thismachine% setenv DISPLAY othermachine:0;
	thismachine% gdb application	# Your favorite debugger.
	or this:
	othermachine% xhost +thismachine
	thismachine% gdb application
	(gdb) set environment DISPLAY othermachine:0
	(gdb) run ...

I believe CodeCenter, a C interpreter/graphical debugger has a method
of dealing with this by explicitely calling the Xlib functions to
release any grabs during breakpoints.

Debugging widget problems requires pretty good debugging skills and
knowledge of how widgets work.  You can go a long way without knowing
the internals of a particular widget but not very far without
understanding how a widget works.  Judicious use of conditional
breakpoints and adding print statements with the debugger help a great
deal.

----------------------------------------------------------------------
26. Why don't XtAddInput(), XtAddTimeout() and XtAddWorkProc() work?
----------------------------------------------------------------------
   I have got a delicate problem with the three routines XtAddInput,
   XtAddTimeOut and XtAddWorkProc. The problem I have is that when
   I use them in my application they seem not to be registred properly.
   I have made a handy little testprogram where everything works
   perfect, but in my "real" application nothing happens. 

The introduction in R3 of the XtApp*() functions obsoleted those
routines (see Q19 for other changes in R3, R4, and R5).  What happens is
they use a default application context different then the one you may
have created.  Since events and timeouts are distributed on a per
application context basis and you are using two application contexts,
you won't get those events.

For example:

	...
	cnt = 0;
	toplevel = XtAppInitialize(&app, class,
				   Desc, XtNumber (Desc),
				   &argc, argv,
				   Fallback, args, cnt);

	XtAddTimeOut (...)
	XtAddWorkProc (...)

	XtAppMainLoop (app)

would never invoke the timeout.

----------------------------------------------------------------------
27. What is and how can I implement drag and drop?
----------------------------------------------------------------------
(Courtesy of Roger Reynolds, rogerr@netcom.com; 19 Feb 93)

Drag-n-drop is a buzzword for moving data between clients, in an
``intuitive'' fashion.

Motif Version 1.2 supports drag-n-drop capabilities, OpenLook has
supported d-n-d all along.  The two protocols are not compatable with
each other, and so far as I know, they are not published.

I wrote a package called RDD which is designed to be a flexible public
protocol for doing drag 'n drop operations between clients.  My
intention was to provide a tool which would make it easy for people to
support a "standard" drag-n-drop protocol in the programs they develop
and contribute or sell, regardless of what widget set is used (as long
as it is based on Xt).

The implementation is based upon my understanding of the ICCCM
conventions, for more details read the code.

I have heard from dozens of people using RDD who like it and feel that
it works a whole lot better than Motif 1.2 stuff.  Also, there seem to
be many who think that it is neat but are constrained to use Motif
anyway.

The latest RDD (and some other stuff) is available for ftp from
netcom.com, in /pub/rogerr.  A (possibly older) version is also
available on export.lcs.mit.edu in /contrib.
-- 
Pete Ware					ware@cis.ohio-state.edu
CIS Dept, Ohio State University			w/ (614) 292-7318
228 Bolz Hall, 2036 Neil Ave.			h/ (614) 538-0965
Columbus, OH 43210

Xref: cantaloupe.srv.cs.cmu.edu comp.windows.x.motif:16266 comp.windows.x:66398 comp.object:10196 comp.lang.c++:40716
Newsgroups: comp.windows.x.motif,comp.windows.x,comp.object,comp.lang.c++
Path: cantaloupe.srv.cs.cmu.edu!crabapple.srv.cs.cmu.edu!fs7.ece.cmu.edu!europa.eng.gtefsd.com!howland.reston.ans.net!noc.near.net!uunet!mdisea!mothost!lmpsbbs!tt718!stevevr
From: stevevr@tt718.ecs.comm.mot.com (Steve Vranyes)
Subject: Re: TeleUse, UIM/X, and C++
Organization: Motorola Land Mobile Products Sector
Date: Mon, 5 Apr 1993 20:11:36 GMT
Message-ID: <1993Apr5.201136.7197@lmpsbbs.comm.mot.com>
References:  <1993Apr1.213842.6086@ctp.com>
Sender: stevevr@tt718 (Steve Vranyes)
Nntp-Posting-Host: 145.1.155.12
Lines: 32

In article <1993Apr1.213842.6086@ctp.com>, hubec@ctp.com (Hubert Chou) writes:
|> Does anyone have any good ideas on how to integrate C++ code elegantly
|> with TeleUse, UIM/X / Interface Architect generated code?
|> 
|> Source would be great, but any suggestions are welcome.
|> 
|> 
|> Hubie Chou
|> (617) 374-8454
|> hubec@ctp.com
|> 

I don't know a great deal about the support for C++ in UIM/X, but I can tell 
you that there is good support for it in TeleUSE.  In TeleUSE you can call any
C++ method from a "D" module.  What you can do then is to use the "D" language
for most of your interface code and then use C++ for you application code.

I should tell you that there is some real neat stuff coming out of TeleUSE soon
in regard to C++, but I can't give you many details.  You should talk to your local sales rep and get the lowdown on what they will be doing in the near furture.

If you want example code of how C++ integrates with TeleUSE you should look at
$TeleUSE/examples/Thermometer

-- 
+------------------------------------------------------------------------------+
|Steve Vranyes                                                                 |
|Voice    : (708) 576 - 0338                                                   |
|E-mail   : stevevr@ecs.comm.mot.com                                           |
|U.S.Post : Motorola Inc.                                                      |
|           1301 E. Algonquin Rd.                                              |
|           Schaumburg, IL 60196                                               |
+------------------------------------------------------------------------------+
Xref: cantaloupe.srv.cs.cmu.edu comp.unix.ultrix:20072 comp.windows.x:66399
Path: cantaloupe.srv.cs.cmu.edu!das-news.harvard.edu!ogicse!decwrl!uunet!ug!jan
From: jan@camhpp12.mdcbbs.com (Jan Vandenbrande)
Newsgroups: comp.unix.ultrix,comp.windows.x
Subject: xv -root with vue? (was Re: xloadimage -onroot ...)
Message-ID: <1993Apr5.113128.2936@ug.eds.com>
Date: 5 Apr 93 18:31:27 GMT
Article-I.D.: ug.1993Apr5.113128.2936
References: <C4npHv.194@ie.utoronto.ca> <C4oE4t.5KE@murdoch.acc.Virginia.EDU> <WHALEY.93Apr3113732@behemoth.kpc.com>
Organization: M&E (Division of EDS), Cypress CA
Lines: 16
Nntp-Posting-Host: 134.244.49.156

On a related note, how can I use xv to display colored GIFs on my
root display with HP Vue?

All I can do with Vue is display xbm's through their
Backdrop Style Manager.

xv does not seem to be able to override whatever Vue
puts there.

Thanks, Jan

-- 
Jan Vandenbrande
jan@ug.eds.com			(New address)
jan@lipari.usc.edu		(school address, forwards)
UUCP: {uunet, uupsi}!ug!jan
Newsgroups: comp.windows.x
Path: cantaloupe.srv.cs.cmu.edu!crabapple.srv.cs.cmu.edu!fs7.ece.cmu.edu!europa.eng.gtefsd.com!howland.reston.ans.net!noc.near.net!uunet!decwrl!netcomsv!netcom.com!zack
From: zack@netcom.com (Zack T. Smith)
Subject: Strange exposure problem
Message-ID: <zackC519wy.Gy4@netcom.com>
Organization: NETCOM On-line Communication Services (408 241-9760 guest)
Date: Mon, 5 Apr 1993 23:14:57 GMT
Lines: 19

Hi, 

I'm trying to write a Motif program on an Interactive Unix machine, and I'm
observing very strange behavior when my program attempts to expose a
DrawingArea. Namely, some Xlib operations work, and some do not. In
particular, the expose consist of two XFillRectangle calls followed by some
XDrawPoint calls, and for reasons unknown to me the point calls are failing
whenever a pulldown or popup up menu is (clicked on and) moved in the
rightward direction over the drawing area, but after the move, is still on
some part of the drawing area. This also happens less consistently when the
pulldown/popup is moved in the leftward direction.

Assuming that my code is not doing anything incredibly odd, is this a server
bug?

Thanks,

Zack T. Smith
Path: cantaloupe.srv.cs.cmu.edu!crabapple.srv.cs.cmu.edu!fs7.ece.cmu.edu!europa.eng.gtefsd.com!howland.reston.ans.net!usenet.ins.cwru.edu!news.ysu.edu!yfn.ysu.edu!ai900
From: ai900@yfn.ysu.edu (Joshua P. Weage)
Newsgroups: comp.windows.x
Subject: X for PC
Date: 5 Apr 1993 23:50:01 GMT
Organization: Youngstown State/Youngstown Free-Net
Lines: 18
Message-ID: <1pqgj9$e1e@news.ysu.edu>
NNTP-Posting-Host: yfn.ysu.edu


I have heard of two packages for the PC that support X-Win.
The first is Linux which is a free Unix Package.  The Second
is X-Appeal, which sounds pretty good.  It can be found at
 garbo.uwusa.fi in the ~ftp/pc/demo/ dir.  The files are

	xap13exe.zip
	xap10fon.zip
	drivers.zip

This should get you started.

Josh.
-- 
+  Joshua Weage : U.S. Snail - 277 Spring Rd, Baroda, MI  49101 +
+  E-Mail: cs890@freenet-in-a.cwru.edu |  ai900@yfn.ysu.edu     +
+   Fidonet:  Joshua Weage @ 1:2340/130                         +
+  All ideas are my own and no one elses!!                      +
Newsgroups: comp.windows.x
Path: cantaloupe.srv.cs.cmu.edu!crabapple.srv.cs.cmu.edu!fs7.ece.cmu.edu!europa.eng.gtefsd.com!emory!wupost!zaphod.mps.ohio-state.edu!usc!elroy.jpl.nasa.gov!ames!nsisrv!news1.gsfc.nasa.gov!ice.stx.com!andy
From: andy@ice.stx.com (Andy Moore)
Subject: Q: How to avoid XOpenDisplay hang?
Message-ID: <C512xr.3oy@skates.gsfc.nasa.gov>
Keywords: Xlib
Sender: usenet@skates.gsfc.nasa.gov
Reply-To: andy@ice.stx.com
Organization: Hughes STX, Lanham, MD
Date: Mon, 5 Apr 1993 20:44:14 GMT
Lines: 13

I'm writing 'xwall', a simple X version of 'wall', and I want it to
put a message up on each of a default list of displays.  The problem
is that XOpenDisplay hangs if one of the displays is currently
controlled by xdm (login screen).   I've been through the manuals
and FAQ and don't see a simple way to see if a display is 'openable'
ahead of time, or to get XOpenDisplay to fail after a short period
of time.  Any hints, suggestions, clues, or pointers to info?  Thanks...

-- 
Andy Moore (andy@ice.stx.com)
_______________________________________________________________________________
"You could say I've lost faith in the politicians/
 They all seem like game show hosts to me..."          - Sting
Path: cantaloupe.srv.cs.cmu.edu!crabapple.srv.cs.cmu.edu!fs7.ece.cmu.edu!europa.eng.gtefsd.com!gatech!swrinde!zaphod.mps.ohio-state.edu!usc!elroy.jpl.nasa.gov!ames!agate!ucsee.Berkeley.EDU!ewang
From: ewang@ucsee.Berkeley.EDU (Edward Wang)
Newsgroups: comp.windows.x
Subject: Widget source code needed
Date: 5 Apr 1993 23:57:43 GMT
Organization: University of California, Berkeley
Lines: 10
Message-ID: <1pqh1n$o7u@agate.berkeley.edu>
NNTP-Posting-Host: ucsee.berkeley.edu

I'm considering writing my own widgets, but I like to have some sample
widget source code to look over first.  Where could I find something
like this?  Are there any archives accessible by anonymous ftp that contain 
such information?

							Thanks,
							Edward
